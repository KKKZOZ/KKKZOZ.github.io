

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Liu Jinyi">
  <meta name="keywords" content="">
  
    <meta name="description" content="Explore Rust Chapter 3 Types Arrays 不支持动态开数组： 1234&#x2F;&#x2F; an array of 100 int32 elements, all set to 1let mut arr1 &#x3D; [1;100]; &#x2F;&#x2F; correctlet n &#x3D; 100;let mur arr2 &#x3D; [1;c]; &#x2F;&#x2F; error Vectors 123let mut arr &#x3D; v">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust Learning Note">
<meta property="og:url" content="http://blog.kkkzoz.top/2024/02/10/learning/Explore_Rust/index.html">
<meta property="og:site_name" content="Kelicopter&#39;s Blog">
<meta property="og:description" content="Explore Rust Chapter 3 Types Arrays 不支持动态开数组： 1234&#x2F;&#x2F; an array of 100 int32 elements, all set to 1let mut arr1 &#x3D; [1;100]; &#x2F;&#x2F; correctlet n &#x3D; 100;let mur arr2 &#x3D; [1;c]; &#x2F;&#x2F; error Vectors 123let mut arr &#x3D; v">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240204161742664.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240207104118126.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240209184800948.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240210111243798.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240210112953117.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240210120702288.png">
<meta property="article:published_time" content="2024-02-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-03-25T08:45:07.602Z">
<meta property="article:author" content="Liu Jinyi">
<meta property="article:tag" content="Learning">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240204161742664.png">
  
  
  
  <title>Rust Learning Note - Kelicopter&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.kkkzoz.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kelicopter</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust Learning Note"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-10 00:00" pubdate>
          February 10, 2024 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          59k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          492 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Rust Learning Note</h1>
            
            
              <div class="markdown-body">
                
                <h1>Explore Rust</h1>
<h2 id="Chapter-3-Types">Chapter 3 Types</h2>
<h3 id="Arrays">Arrays</h3>
<p>不支持动态开数组：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// an array of 100 int32 elements, all set to 1</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arr1</span> = [<span class="hljs-number">1</span>;<span class="hljs-number">100</span>]; <span class="hljs-comment">// correct</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">mur</span> arr2 = [<span class="hljs-number">1</span>;c]; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<h3 id="Vectors">Vectors</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arr</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>];<br>arr.<span class="hljs-title function_ invoke__">sort</span>() <span class="hljs-comment">// increasing order</span><br>arr.<span class="hljs-title function_ invoke__">sort_by</span>(|a,b| b.<span class="hljs-title function_ invoke__">cmp</span>(a)) <span class="hljs-comment">// decreasing order</span><br></code></pre></td></tr></table></figure>
<p>If you know the number of elements a vector will need in advance, instead of <code>Vec::new</code> you can call <code>Vec::with_capacity</code> to create a vector with a buffer large enough to hold them all, right from the start.</p>
<h3 id="String">String</h3>
<p>A String or &amp;str’s .len() method returns its length. The length is measured in bytes, not characters:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;ಠ_ಠ&quot;</span>.<span class="hljs-title function_ invoke__">len</span>(), <span class="hljs-number">7</span>); <br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-string">&quot;ಠ_ಠ&quot;</span>.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">count</span>(), <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<h3 id="Type-Aliases">Type Aliases</h3>
<p>The type keyword can be used like typedef in C++ to declare a new name for an existing type:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Bytes</span> = <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt;;<br></code></pre></td></tr></table></figure>
<h2 id="Chapter-4-Ownership">Chapter 4 Ownership</h2>
<h3 id="Moves">Moves</h3>
<p>What if you really do want to move an element out of a vector? You need to find a method that does so in a way that respects the limitations of the type. Here are three possibilities:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Build a vector of the strings &quot;101&quot;, &quot;102&quot;, ... &quot;105&quot; </span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>(); <br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">101</span> .. <span class="hljs-number">106</span> &#123; v.<span class="hljs-title function_ invoke__">push</span>(i.<span class="hljs-title function_ invoke__">to_string</span>()); &#125; <br><br><span class="hljs-comment">// 1. Pop a value off the end of the vector: </span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">fifth</span> = v.<span class="hljs-title function_ invoke__">pop</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;vector empty!&quot;</span>); <br><span class="hljs-built_in">assert_eq!</span>(fifth, <span class="hljs-string">&quot;105&quot;</span>); <br><br><span class="hljs-comment">// 2. Move a value out of a given index in the vector, </span><br><span class="hljs-comment">// and move the last element into its spot: </span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = v.<span class="hljs-title function_ invoke__">swap_remove</span>(<span class="hljs-number">1</span>); <br><span class="hljs-built_in">assert_eq!</span>(second, <span class="hljs-string">&quot;102&quot;</span>); <br><br><span class="hljs-comment">// 3. Swap in another value for the one we&#x27;re taking out: </span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span> = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> v[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;substitute&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()); <br><span class="hljs-built_in">assert_eq!</span>(third, <span class="hljs-string">&quot;103&quot;</span>); <br><br><span class="hljs-comment">// Let&#x27;s see what&#x27;s left of our vector. </span><br><span class="hljs-built_in">assert_eq!</span>(v, <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;101&quot;</span>, <span class="hljs-string">&quot;104&quot;</span>, <span class="hljs-string">&quot;substitute&quot;</span>]);<br></code></pre></td></tr></table></figure>
<h3 id="Copy-Types">Copy Types</h3>
<p>The standard <code>Copy</code> types include all the machine integer and floating-point numeric types, the <code>char</code> and <code>bool</code> types, and a few others. A tuple or fixed-size array of <code>Copy</code> types is itself a <code>Copy</code> type.</p>
<blockquote>
<p>As a rule of thumb, any type that needs to do something special when a value is dropped cannot be Copy: a Vec needs to free its elements, a File needs to close its file handle, a MutexGuard needs to unlock its mutex, and so on.</p>
</blockquote>
<p>By default, struct and enum types are not <code>Copy</code>.</p>
<p>If all the fields of your struct are themselves Copy, then you can make the type Copy as well by placing the attribute <code>#[derive(Copy, Clone)]</code> above the definition, like so:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Copy, Clone)]</span> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Label</span> &#123; number: <span class="hljs-type">u32</span> &#125;<br></code></pre></td></tr></table></figure>
<h3 id="Rc-and-Arc-Shared-Ownership">Rc and Arc: Shared Ownership</h3>
<p>In some cases it’s difficult to find every value a single owner that has the lifetime you need; you’d like the value to simply live until everyone’s done using it. For these cases, Rust provides the reference-counted pointer types <code>Rc</code> and <code>Arc</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc; <br><span class="hljs-comment">// Rust can infer all these types; written out for clarity </span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: Rc&lt;<span class="hljs-type">String</span>&gt; = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;shirataki&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()); <br><span class="hljs-keyword">let</span> <span class="hljs-variable">t</span>: Rc&lt;<span class="hljs-type">String</span>&gt; = s.<span class="hljs-title function_ invoke__">clone</span>(); <br><span class="hljs-keyword">let</span> <span class="hljs-variable">u</span>: Rc&lt;<span class="hljs-type">String</span>&gt; = s.<span class="hljs-title function_ invoke__">clone</span>();<br></code></pre></td></tr></table></figure>
<p>For any type T, an <code>Rc&lt;T&gt;</code> value is a pointer to a heap-allocated T that has had a reference count affixed to it.</p>
<p><strong>Cloning an <code>Rc&lt;T&gt;</code> value does not copy the T; instead, it simply creates another pointer to it and increments the reference count.</strong></p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240204161742664.png" alt="image-20240204161742664"></p>
<p><strong>A value owned by an Rc pointer is immutable.</strong></p>
<h2 id="Chapter-5-References">Chapter 5 References</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Table</span> = HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(table: &amp;Table) &#123; <br>    <span class="hljs-keyword">for</span> (artist, works) <span class="hljs-keyword">in</span> table &#123; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;works by &#123;&#125;:&quot;</span>, artist); <br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">work</span> <span class="hljs-keyword">in</span> works &#123; <br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot; &#123;&#125;&quot;</span>, work); <br>        &#125; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>This code is fine. Are you wondering why <code>for work in works</code> does not consume the <code>String</code>?</p>
<p>It receives a shared reference to the HashMap. Iterating over a shared reference to a <code>HashMap</code> is defined to produce shared references to each entry’s key and value: artist has changed from a String to a &amp;String, and works from a <code>Vec&lt;String&gt;</code> to a <code>&amp;Vec&lt;String&gt;</code>. Iterating over a shared reference to a <code>vector</code> is defined to produce shared references to its elements, too.</p>
<ul>
<li>Since references are so widely used in Rust, the <code>.</code> operator implicitly dereferences its left operand.</li>
<li>The <code>.</code> operator can also implicitly borrow a reference to its left operand, if needed for a method call.</li>
</ul>
<h2 id="Chapter-6-Expressions">Chapter 6 Expressions</h2>
<h3 id="An-Expression-Language">An Expression Language</h3>
<p>In C, <code>if</code> and <code>switch</code> are statements. They don’t produce a value, and they can’t be used in the middle of an expression. In Rust, <code>if</code> and <code>match</code> can produce values.</p>
<blockquote>
<p>This explains why Rust does not have C’s ternary operator (<code>expr 1 ? expr 2 : expr 3</code>). In C, it is a handy expression-level analogue to the <code>if</code> statement. It would be redundant in Rust: the <code>if</code> expression handles both cases.</p>
</blockquote>
<h3 id="Blocks-and-Semicolons">Blocks and Semicolons</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = &#123; <br>    <span class="hljs-comment">// let-declaration: semicolon is always required </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dandelion_control</span> = puffball.<span class="hljs-title function_ invoke__">open</span>(); <br><br>    <span class="hljs-comment">// expression + semicolon: method is called, return value dropped </span><br>    dandelion_control.<span class="hljs-title function_ invoke__">release_all_seeds</span>(launch_codes); <br><br>    <span class="hljs-comment">// expression with no semicolon: method is called, </span><br>    <span class="hljs-comment">// return value stored in `msg` </span><br>    dandelion_control.<span class="hljs-title function_ invoke__">get_status</span>() <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>A block can also contain item declarations. An item is simply any declaration that could appear globally in a program or module, such as a <code>fn</code>, <code>struct</code>, or <code>use</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io; <br><span class="hljs-keyword">use</span> std::cmp::Ordering; <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_files</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[]; <br>    ... <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp_by_timestamp_then_name</span>(a: &amp;FileInfo, b: &amp;FileInfo) <span class="hljs-punctuation">-&gt;</span> Ordering &#123; <br>        a.timestamp.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b.timestamp) <span class="hljs-comment">// first, compare timestamps </span><br>            .<span class="hljs-title function_ invoke__">reverse</span>() <span class="hljs-comment">// newest file first </span><br>            .<span class="hljs-title function_ invoke__">then</span>(a.path.<span class="hljs-title function_ invoke__">cmp</span>(&amp;b.path)) <span class="hljs-comment">// compare paths to break ties </span><br>        &#125; <br>        <br>        v.<span class="hljs-title function_ invoke__">sort_by</span>(cmp_by_timestamp_then_name); <br>        ... <br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="if-let">if let</h3>
<p>There is one more <code>if</code> form, the <code>if let</code> expression:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">pattern</span> = expr &#123;<br> block1 <br>&#125; <span class="hljs-keyword">else</span> &#123; <br> block2 <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Loops">Loops</h3>
<p>There are four looping expressions:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">while</span> condition &#123; <br>    block <br>&#125; <br><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">pattern</span> = expr &#123; <br>    block <br>&#125; <br><br><span class="hljs-keyword">loop</span> &#123; <br>    block <br>&#125; <br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">pattern</span> <span class="hljs-keyword">in</span> iterable &#123; <br>    block <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Loops are expressions in Rust, but the value of a <code>while</code> or <code>for</code> loop is always <code>()</code>, so their value isn’t very useful. A <code>loop</code> expression can produce a value if you specify one.</p>
<h3 id="Function-and-Method-Calls">Function and Method Calls</h3>
<p>Rust usually makes a sharp distinction between references and the values they refer to.</p>
<ul>
<li>If you pass a <code>&amp;i32</code> to a function that expects an <code>i32</code>, that’s a type error.</li>
<li>You’ll notice that the <code>.</code> operator relaxes those rules a bit.
<ul>
<li>In the method call <code>player.location()</code>, player might be a<code>Player</code>, a reference of type <code>&amp;Player</code>, or a smart pointer of type <code>Box&lt;Player&gt;</code> or <code>Rc&lt;Player&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="Fields-and-Elements">Fields and Elements</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">.. b <span class="hljs-comment">// RangeTo &#123; end: b &#125; </span><br>a .. b <span class="hljs-comment">// Range &#123; start: a, end: b &#125;</span><br><br>..= b <span class="hljs-comment">// RangeToInclusive &#123; end: b &#125; </span><br>a ..= b <span class="hljs-comment">// RangeInclusive::new(a, b)</span><br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">quicksort</span>&lt;T: <span class="hljs-built_in">Ord</span>&gt;(slice: &amp;<span class="hljs-keyword">mut</span> [T]) &#123; <br>    <span class="hljs-keyword">if</span> slice.<span class="hljs-title function_ invoke__">len</span>() &lt;= <span class="hljs-number">1</span> &#123; <br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// Nothing to sort. </span><br>    &#125; <br><br>    <span class="hljs-comment">// Partition the slice into two parts, front and back. </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">pivot_index</span> = <span class="hljs-title function_ invoke__">partition</span>(slice); <br><br>    <span class="hljs-comment">// Recursively sort the front half of `slice`. </span><br>    <span class="hljs-title function_ invoke__">quicksort</span>(&amp;<span class="hljs-keyword">mut</span> slice[.. pivot_index]); <br>    <br>    <span class="hljs-comment">// And the back half. </span><br>    <span class="hljs-title function_ invoke__">quicksort</span>(&amp;<span class="hljs-keyword">mut</span> slice[pivot_index + <span class="hljs-number">1</span> ..]); <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Reference-Operators">Reference Operators</h3>
<p>The unary <code>*</code> operator is used to access the value pointed to by a reference. As we’ve seen, Rust automatically follows references when you use the <code>.</code> operator to access a field or method, <em><strong>so the <code>*</code> operator is necessary only when we want to read or write the entire value that the reference points to.</strong></em></p>
<h3 id="Type-Casts">Type Casts</h3>
<p>Converting a value from one type to another usually requires an explicit cast in Rust. Casts use the <code>as</code> keyword:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">17</span>; <span class="hljs-comment">// x is type i 32 </span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">index</span> = x <span class="hljs-keyword">as</span> <span class="hljs-type">usize</span>; <span class="hljs-comment">// convert to usize</span><br></code></pre></td></tr></table></figure>
<p>Several more significant automatic conversions can happen, though:</p>
<ul>
<li>Values of type <code>&amp;String</code> auto-convert to type<code>&amp;str</code> without a cast.</li>
<li>alues of type <code>&amp;Vec&lt;i32&gt;</code> auto-convert to <code>&amp;[i32]</code>.</li>
<li>Values of type <code>&amp;Box&lt;Chessboard&gt;</code> auto-convert to <code>&amp;Chessboard</code>.</li>
</ul>
<p>These are called <em><strong>deref coercions</strong></em>, because they apply to types that implement the <code>Deref</code> built-in trait. The purpose of <code>Deref</code> coercion is to make smart pointer types, like <code>Box</code>, behave as much like the underlying value as possible. Using a <code>Box&lt;Chessboard&gt;</code> is mostly just like using a plain <code>Chessboard</code>, thanks to <code>Deref</code>.</p>
<h2 id="Chapter-7-Error-Handling">Chapter 7 Error Handling</h2>
<h3 id="Panic">Panic</h3>
<p>Perhaps <code>panic</code> is a misleading name for this orderly process. A panic is not a crash. It’s not undefined behavior. It’s more like a <code>RuntimeException</code> in Java or a <code>std::logic_error</code> in C++. <strong>The behavior is well-defined; it just shouldn’t be happening.</strong></p>
<h3 id="Result">Result</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_weather</span>(location: LatLng) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;WeatherReport, io::Error&gt;<br></code></pre></td></tr></table></figure>
<h4 id="Catching-Errors">Catching Errors</h4>
<p>The most thorough way of dealing with a <code>Result</code> is to use a <code>match</code> expression.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">get_weather</span>(hometown) &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(report) =&gt; &#123;<br>        <span class="hljs-title function_ invoke__">display_weather</span>(hometown, &amp;report);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Err</span>(err) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;error querying the weather: &#123;&#125;&quot;</span>, err);<br>        <span class="hljs-title function_ invoke__">schedule_weather_retry</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Result&lt;T, E&gt;</code> offers a variety of methods that are useful in particular common cases. Each of these methods has a <code>match</code> expression in its implementation:</p>
<ul>
<li><code>result.is_ok()</code>, <code>result.is_err()</code>
<ul>
<li>Return a <code>bool</code> telling if <code>result</code> is a success result or an error result.</li>
</ul>
</li>
<li><code>result.ok()</code>
<ul>
<li>Returns the success value, if any, as an <code>Option&lt;T&gt;</code>. If result is a success result, this returns <code>Some(success_value)</code>; otherwise, it returns None, discarding the <code>error</code> value.</li>
</ul>
</li>
<li><code>result.err()</code>
<ul>
<li>Returns the error value, if any, as an <code>Option&lt;E&gt;</code>.</li>
</ul>
</li>
<li><code>result.unwrap_or(fallback)</code>
<ul>
<li>Returns the success value, if result is a success result. Otherwise, it returns <code>fallback</code>, discarding the error value.</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// A fairly safe prediction for Southern California. </span><br>    <span class="hljs-keyword">const</span> THE_USUAL: WeatherReport = WeatherReport::<span class="hljs-title function_ invoke__">Sunny</span>(<span class="hljs-number">72</span>); <br>    <span class="hljs-comment">// Get a real weather report, if possible. </span><br>    <span class="hljs-comment">// If not, fall back on the usual. </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">report</span> = <span class="hljs-title function_ invoke__">get_weather</span>(los_angeles).<span class="hljs-title function_ invoke__">unwrap_or</span>(THE_USUAL); <span class="hljs-title function_ invoke__">display_weather</span>(los_angeles, &amp;report);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>result.unwrap_or_else(fallback_fn)</code>
<ul>
<li>This is the same, but instead of passing a fallback value directly, you pass a function or closure. This is for cases where it would be wasteful to compute a fallback value if you’re not going to use it. The <code>fallback_fn</code> is called only if we have an error result.</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">report</span> = <br>    <span class="hljs-title function_ invoke__">get_weather</span>(hometown)<br>    .<span class="hljs-title function_ invoke__">unwrap_or_else</span>(|_err| <span class="hljs-title function_ invoke__">vague_prediction</span>(hometown));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>result.unwrap()</code>
<ul>
<li>Also returns the success value, if <code>result</code> is a success result. However, if result is an error result, this method panics.</li>
</ul>
</li>
<li><code>result.expect(message)</code>
<ul>
<li>This the same as <code>.unwrap()</code>, but lets you provide a message that it prints in case of panic.</li>
</ul>
</li>
<li><code>result.as_ref()</code>
<ul>
<li>Converts a <code>Result&lt;T, E&gt;</code> to a <code>Result&lt;&amp;T, &amp;E&gt;</code>.</li>
</ul>
</li>
<li><code>result.as_mut()</code>
<ul>
<li>This is the same, but borrows a mutable reference. The return type is <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>For example, suppose you’d like to call <code>result.ok()</code>, but you need result to be left intact. You can write <code>result.as_ref().ok()</code>, which merely borrows result, returning an <code>Option&lt;&amp;T&gt;</code> rather than an <code>Option&lt;T&gt;</code>.</p>
</blockquote>
<h3 id="Result-Type-Aliases">Result Type Aliases</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">remove_file</span>(path: &amp;Path) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt;<br></code></pre></td></tr></table></figure>
<p>This means that a <code>Result</code> type alias is being used.</p>
<p>Modules often define a Result type alias to avoid having to repeat an error type that’s used consistently by almost every function in the module. For example, the standard library’s std::io module includes this line of code:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = result::<span class="hljs-type">Result</span>&lt;T, Error&gt;;<br></code></pre></td></tr></table></figure>
<p>Printing an error value does not also print out its source. If you want to be sure to print all the available information, use this function:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::io::&#123;stderr, Write&#125;;<br><span class="hljs-comment">/// Dump an error message to `stderr`.</span><br><span class="hljs-comment">///</span><br><span class="hljs-comment">/// If another error happens while building the error message or</span><br><span class="hljs-comment">/// riting to `stderr`, it is ignored.</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_error</span>(<span class="hljs-keyword">mut</span> err: &amp;<span class="hljs-keyword">dyn</span> Error) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-built_in">writeln!</span>(<span class="hljs-title function_ invoke__">stderr</span>(), <span class="hljs-string">&quot;error: &#123;&#125;&quot;</span>, err);<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(source) = err.<span class="hljs-title function_ invoke__">source</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_</span> = <span class="hljs-built_in">writeln!</span>(<span class="hljs-title function_ invoke__">stderr</span>(), <span class="hljs-string">&quot;caused by: &#123;&#125;&quot;</span>, source);<br>        err = source;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Propagating-Errors">Propagating Errors</h4>
<p>Rust has a <code>?</code> operator that does this.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">weather</span> = <span class="hljs-title function_ invoke__">get_weather</span>(hometown)?;<br></code></pre></td></tr></table></figure>
<ul>
<li>On success, it unwraps the Result to get the success value inside. The type of weather here is not <code>Result&lt;WeatherReport, io::Error&gt;</code> but simply <code>WeatherReport</code>.</li>
<li>On error, it immediately returns from the enclosing function, passing the error result up the call chain. To ensure that this works, <code>?</code> can only be used on a <code>Result</code> in functions that have a <code>Result</code> return type.</li>
</ul>
<p><code>?</code> also works similarly with the <code>Option</code> type. In a function that returns Option, you can use <code>?</code> to unwrap a value and return early in the case of <code>None</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">weather</span> = <span class="hljs-title function_ invoke__">get_weather</span>(hometown).<span class="hljs-title function_ invoke__">ok</span>()?;<br></code></pre></td></tr></table></figure>
<h4 id="Working-with-Multiple-Error-Types">Working with Multiple Error Types</h4>
<p>All of the standard library error types can be converted to the type <code>Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;</code>：</p>
<ul>
<li><code>dyn std::error::Error</code> represents “any error”</li>
<li><code>Send + Sync + 'static</code> makes it safe to pass between threads</li>
</ul>
<p>For convenience, you can define type aliases:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">GenericError</span> = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> std::error::Error + <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span> + <span class="hljs-symbol">&#x27;static</span>&gt;; <br><span class="hljs-keyword">type</span> <span class="hljs-title class_">GenericResult</span>&lt;T&gt; = <span class="hljs-type">Result</span>&lt;T, GenericError&gt;;<br></code></pre></td></tr></table></figure>
<p>To convert any error to the GenericError type, call <code>GenericError::from()</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">io_error</span> = io::Error::<span class="hljs-title function_ invoke__">new</span>(io::ErrorKind::Other, <span class="hljs-string">&quot;timed out&quot;</span>); <span class="hljs-comment">// make our own io::Error </span><br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(GenericError::<span class="hljs-title function_ invoke__">from</span>(io_error)); <span class="hljs-comment">// manually convert to GenericError</span><br></code></pre></td></tr></table></figure>
<h2 id="Chapter-8-Crates-and-Modules">Chapter 8 Crates and Modules</h2>
<h3 id="Crates">Crates</h3>
<p>Rust programs are made of <strong>crates</strong>. Each crate is a complete, cohesive unit: all the source code for a single library or executable, plus any associated tests, examples, tools, configuration, and other junk.</p>
<h3 id="Editions">Editions</h3>
<p>Rust promises that the compiler will always accept all extant editions of the language, and programs can freely mix crates written in different editions.</p>
<p>It’s even fine for a 2015 edition crate to depend on a 2018 edition crate. In other words, a crate’s edition only affects how its source code is construed; <em><strong>edition distinctions are gone by the time the code has been compiled.</strong></em> This means there’s no pressure to update old crates just to continue to participate in the modern Rust ecosystem.</p>
<h3 id="Modules">Modules</h3>
<p>Whereas crates are about code sharing between projects, <strong>modules</strong> are about code organization <strong>within</strong> a project.</p>
<p>They act as Rust’s namespaces, containers for the functions, types, constants, and so on that make up your Rust program or library.</p>
<p>Anything that isn’t marked <code>pub</code> is private and can only be used in the same module in which it is defined, or any child modules.</p>
<p>It’s also possible to specify <code>pub(super)</code>, making an item visible to the parent module only, and <code>pub(in &lt;path&gt;)</code>, which makes it visible in a specific parent module and its descendants.</p>
<p>A module can have its own directory. When Rust sees <code>mod spores;</code>, it checks for both <code>spores.rs</code> and <code>spores/mod.rs</code>; if neither file exists, or both exist, that’s an error.</p>
<p>The code in <code>src/lib.rs</code> forms the <strong>root module</strong> of the library. Other crates that use our library can only access the public items of this root module.</p>
<h4 id="The-src-bin-Directory">The src/bin Directory</h4>
<p>Cargo has some built-in support for small programs that live in the same crate as a library.</p>
<p>We can keep our program and our library in the same crate, too. Put this code into a file named <code>src/bin/efern.rs</code></p>
<h3 id="Test-and-Documentation">Test and Documentation</h3>
<p>Rust’s test harness uses multiple threads to run several tests at a time, a nice side benefit of your Rust code being thread-safe by default. To disable this, either run a single test, <code>cargo test testname</code>, or run <code>cargo test -- --test-threads 1</code>. (The first <code>--</code> ensures that cargo test passes the <code>--test-threads</code> option through to the test executable.)</p>
<h4 id="Integration-Tests">Integration Tests</h4>
<p><strong>Integration tests</strong> are <code>.rs</code> files that live in a <em><strong>tests</strong></em> directory alongside your project’s src directory. When you run <code>cargo test</code>, Cargo compiles each integration test as a separate, standalone crate, linked with your library and the Rust test harness.</p>
<blockquote>
<p>Integration tests are valuable in part because they see your crate from the outside, just as a user would. They test the crate’s public API.</p>
</blockquote>
<h4 id="Documentation">Documentation</h4>
<p>When Rust sees comments that start with three slashes, it treats them as a <code>#[doc]</code> attribute instead.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Simulate the production of a spore by meiosis. </span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">produce_spore</span>(factory: &amp;<span class="hljs-keyword">mut</span> Sporangium) <span class="hljs-punctuation">-&gt;</span> Spore &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<p>Comments starting with <code>//!</code> are treated as <code>#![doc]</code> attributes and are attached to the enclosing feature, typically a module or crate. For example, your <code>fern_sim/src/lib.rs</code> file might begin like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">//! Simulate the growth of ferns, from the level of </span><br><span class="hljs-comment">//! individual cells on up.</span><br></code></pre></td></tr></table></figure>
<p>The content of a doc comment is treated as Markdown.</p>
<h4 id="Doc-Tests">Doc-Tests</h4>
<p>When you run tests in a Rust library crate, Rust checks that all the code that appears in your documentation actually runs and works.</p>
<p>It does this by taking each block of code that appears in a doc comment, compiling it as a separate executable crate, linking it with your library, and running it.</p>
<p>Very often a minimal working example includes some details, such as imports or setup code, that are necessary to make the code compile, but just aren’t important enough to show in the documentation. To hide a line of a code sample, put a <code>#</code> followed by a space at the beginning of that line:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Let the sun shine in and run the simulation for a given </span><br><span class="hljs-comment">/// amount of time. </span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">///     # use fern_sim::Terrarium; </span><br><span class="hljs-comment">///     # use std::time::Duration; </span><br><span class="hljs-comment">///     # let mut tm = Terrarium::new(); </span><br><span class="hljs-comment">///     tm.apply_sunlight(Duration::from_secs(60)); </span><br><span class="hljs-comment">/// </span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">apply_sunlight</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, time: Duration) &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<p>Testing can be disabled for specific blocks of code. To tell Rust to compile your example, but stop short of actually running it, use a fenced code block with the <code>no_run</code> annotation:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Upload all local terrariums to the online gallery. </span><br><span class="hljs-comment">/// </span><br><span class="hljs-comment">/// ```no_run </span><br><span class="hljs-comment">/// let mut session = fern_sim::connect(); </span><br><span class="hljs-comment">/// session.upload_all(); </span><br><span class="hljs-comment">/// ``` </span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">upload_all</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<h2 id="Chapter-9-Structs">Chapter 9 Structs</h2>
<h3 id="Interior-Mutability">Interior Mutability</h3>
<p>Now suppose you want to add a little logging to the <code>SpiderRobot</code> struct, using the standard <code>File</code> type. There’s a problem: a <code>File</code> has to be <em>mut</em>. All the methods for writing to it require a mut reference.</p>
<p>This sort of situation comes up fairly often. What we need is a little bit of mutable data (a <code>File</code>) inside an otherwise immutable value (the <code>SpiderRobot</code> struct)</p>
<p>This is called <em><strong>interior mutability</strong></em>. Rust offers several flavors of it:</p>
<ul>
<li><code>Cell&lt;T&gt;</code></li>
<li><code>RefCell&lt;T&gt;</code></li>
</ul>
<p>A <code>Cell&lt;T&gt;</code> is a struct that contains a single private value of type <code>T</code>. The only special thing about a Cell is that <strong>you can get and set the field even if you don’t have mut access to the Cell itself</strong>:</p>
<ul>
<li><code>cell.get()</code>
<ul>
<li>Returns a copy of the value in the <code>cell</code>.</li>
</ul>
</li>
<li><code>cell.set(value)</code>
<ul>
<li>Stores the given <code>value</code> in the cell, dropping the previously stored value.</li>
<li>This method takes <code>self</code> as a <code>non-mut</code> reference:</li>
<li>They’re simply a safe way of bending the rules on immutability—no more, no less.</li>
</ul>
</li>
</ul>
<p>A <code>Cell</code> would be handy if you were adding a simple counter to your SpiderRobot. You could write:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::Cell; <br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpiderRobot</span> &#123; <br>    ... <br>    hardware_error_count: Cell&lt;<span class="hljs-type">u32</span>&gt;, <br>    ... <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Then even non-mut methods of SpiderRobot can access that <code>u32</code>, using the <code>.get()</code> and <code>.set()</code> methods:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SpiderRobot</span> &#123; <br>    <span class="hljs-comment">/// Increase the error count by 1. </span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_hardware_error</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-keyword">self</span>.hardware_error_count.<span class="hljs-title function_ invoke__">get</span>(); <br>        <span class="hljs-keyword">self</span>.hardware_error_count.<span class="hljs-title function_ invoke__">set</span>(n + <span class="hljs-number">1</span>); <br>    &#125; <br><br>    <span class="hljs-comment">/// True if any hardware errors have been reported. </span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">has_hardware_errors</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.hardware_error_count.<span class="hljs-title function_ invoke__">get</span>() &gt; <span class="hljs-number">0</span> <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>Cell</code> does not let you call mut methods on a shared value. The <code>.get()</code> method returns a copy of the value in the cell, so <strong>it works only if <code>T</code> implements the Copy trait.</strong></p>
<p>The right tool in this case is a <code>RefCell</code>. Like <code>Cell&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is a generic type that contains a single value of type <code>T</code>. Unlike Cell, RefCell supports borrowing references to its <code>T</code> value:</p>
<ul>
<li><code>RefCell::new(value)</code>
<ul>
<li>Creates a new <code>RefCell</code>, <strong>moving value into it</strong>.</li>
</ul>
</li>
<li><code>ref_cell.borrow()</code>
<ul>
<li>Returns a <code>Ref&lt;T&gt;</code>, which is essentially just a shared reference to the value stored in ref_cell.</li>
</ul>
</li>
<li><code>ref_cell.borrow_mut()</code>
<ul>
<li>Returns a <code>RefMut&lt;T&gt;</code>, essentially a mutable reference to the value in ref_cell.</li>
</ul>
</li>
<li><code>ref_cell.try_borrow()</code>, <code>ref_cell.try_borrow_mut()</code>
<ul>
<li>Work just like <code>borrow()</code> and <code>borrow_mut()</code>, but return a <code>Result</code>. Instead of panicking if the value is already mutably borrowed, they return an <code>Err</code> value.</li>
</ul>
</li>
</ul>
<p>The only difference is that normally, when you borrow a reference to a variable, Rust <strong>checks at compile time</strong> to ensure that you’re using the reference safely. If the checks fail, you get a compiler error. RefCell enforces the same rule <strong>using run-time checks</strong>.</p>
<p>Cells are easy to use. Having to call <code>.get()</code> and <code>.set()</code> or <code>.borrow()</code> and <code>.borrow_mut()</code> is slightly awkward, but that’s just the price we pay for bending the rules.</p>
<h2 id="Chapter-10-Enums-and-Patterns">Chapter 10 Enums and Patterns</h2>
<h3 id="Enums-with-Data">Enums with Data</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Copy, Clone, Debug, PartialEq)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RoughTime</span> &#123; <br>    <span class="hljs-title function_ invoke__">InThePast</span>(TimeUnit, <span class="hljs-type">u32</span>), <br>    JustNow, <br>    <span class="hljs-title function_ invoke__">InTheFuture</span>(TimeUnit, <span class="hljs-type">u32</span>), <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Two of the variants in this enum, <code>InThePast</code> and <code>InTheFuture</code>, take arguments. These are called <em><strong>tuple variants</strong></em>.</p>
<p>Enums can also have <em><strong>struct variants</strong></em>, which contain named fields, just like ordinary structs:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Shape</span> &#123; <br>    Sphere &#123; center: Point3d, radius: <span class="hljs-type">f32</span> &#125;, <br>    Cuboid &#123; corner1: Point3d, corner2: Point3d &#125;, <br>&#125; <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">unit_sphere</span> = Shape::Sphere &#123; center: ORIGIN, radius: <span class="hljs-number">1.0</span>, &#125;;<br></code></pre></td></tr></table></figure>
<p>A single enum can have variants of all three kinds:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">RelationshipStatus</span> &#123; <br>    Single, <br>    InARelationship, <br>    <span class="hljs-title function_ invoke__">ItsComplicated</span>(<span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;), <br>    ItsExtremelyComplicated &#123; <br>  car: DifferentialEquation, <br>  cdr: EarlyModernistPoem, <br> &#125;, <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Patterns">Patterns</h3>
<p>Suppose you have a <code>RoughTime</code> value and you’d like to display it on a web page. You need to access the TimeUnit and <code>u32</code> fields inside the value. Rust doesn’t let you access them directly, by writing <code>rough_time.0</code> and <code>rough_time.1</code>, because after all, the value might be <code>RoughTime::JustNow</code>, which has no fields.</p>
<p>You need a <code>match</code> expression.</p>
<p><code>other</code> can serve as a catchall pattern:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">calendar</span> = <span class="hljs-keyword">match</span> settings.<span class="hljs-title function_ invoke__">get_string</span>(<span class="hljs-string">&quot;calendar&quot;</span>) &#123; <br>    <span class="hljs-string">&quot;gregorian&quot;</span> =&gt; Calendar::Gregorian, <br>    <span class="hljs-string">&quot;chinese&quot;</span> =&gt; Calendar::Chinese, <br>    <span class="hljs-string">&quot;ethiopian&quot;</span> =&gt; Calendar::Ethiopian, <br>    other =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">parse_error</span>(<span class="hljs-string">&quot;calendar&quot;</span>, other), <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>If you need a catchall pattern, but you don’t care about the matched value, you can use a single underscore <code>_</code> as a pattern, the <em><strong>wildcard pattern</strong></em>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">caption</span> = <span class="hljs-keyword">match</span> photo.<span class="hljs-title function_ invoke__">tagged_pet</span>() &#123; <br>    Pet::Tyrannosaur =&gt; <span class="hljs-string">&quot;RRRAAAAAHHHHHH&quot;</span>, <br>    Pet::Samoyed =&gt; <span class="hljs-string">&quot;*dog thoughts*&quot;</span>, <br>    _ =&gt; <span class="hljs-string">&quot;I&#x27;m cute, love me&quot;</span>, <span class="hljs-comment">// generic caption, works for any pet </span><br>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="Tuple-and-Struct-Patterns">Tuple and Struct Patterns</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">describe_point</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">use</span> std::cmp::Ordering::*;<br>    <span class="hljs-keyword">match</span> (x.<span class="hljs-title function_ invoke__">cmp</span>(&amp;<span class="hljs-number">0</span>), y.<span class="hljs-title function_ invoke__">cmp</span>(&amp;<span class="hljs-number">0</span>)) &#123;<br>        (Equal, Equal) =&gt; <span class="hljs-string">&quot;at the origin&quot;</span>,<br>        (_, Equal) =&gt; <span class="hljs-string">&quot;on the x axis&quot;</span>,<br>        (Equal, _) =&gt; <span class="hljs-string">&quot;on the y axis&quot;</span>,<br>        (Greater, Greater) =&gt; <span class="hljs-string">&quot;in the first quadrant&quot;</span>,<br>        (Less, Greater) =&gt; <span class="hljs-string">&quot;in the second quadrant&quot;</span>,<br>        _ =&gt; <span class="hljs-string">&quot;somewhere else&quot;</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Struct patterns use curly braces, just like struct expressions. They contain a subpattern for each field:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> balloon.location &#123; <br>    Point &#123; x: <span class="hljs-number">0</span>, y: height &#125; =&gt; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;straight up &#123;&#125; meters&quot;</span>, height), <br>    Point &#123; x: x, y: y &#125; =&gt; <br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;at (&#123;&#125;m, &#123;&#125;m)&quot;</span>, x, y), <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Use <code>..</code> to tell Rust you don’t care about any of the other fields:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">Some</span>(Account &#123; name, language, .. &#125;) =&gt; <br>    language.<span class="hljs-title function_ invoke__">show_custom_greeting</span>(name),<br></code></pre></td></tr></table></figure>
<h4 id="Array-and-Slice-Patterns">Array and Slice Patterns</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">hsl_to_rgb</span>(hsl: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]) <span class="hljs-punctuation">-&gt;</span> [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] &#123;<br>    <span class="hljs-keyword">match</span> hsl &#123;<br>        [_, _, <span class="hljs-number">0</span>] =&gt; [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        [_, _, <span class="hljs-number">255</span>] =&gt; [<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>],<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Slice patterns are similar, but unlike arrays, slices have variable lengths, so slice patters match not only on values but also on length.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">greet_people</span>(names: &amp;[&amp;<span class="hljs-type">str</span>]) &#123;<br>    <span class="hljs-keyword">match</span> names &#123;<br>        [] =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, nobody.&quot;</span>)<br>        &#125;<br>        [a] =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;&#125;.&quot;</span>, a)<br>        &#125;<br>        [a, b] =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;&#125; and &#123;&#125;.&quot;</span>, a, b)<br>        &#125;<br>        [a, .., b] =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, everyone from &#123;&#125; to &#123;&#125;.&quot;</span>, a, b)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Reference-Patterns">Reference Patterns</h4>
<p>Rust patterns support two features for working with references:</p>
<ul>
<li><code>ref</code> patterns borrow parts of a matched value.</li>
<li><code>&amp;</code> patterns match references.</li>
</ul>
<p>Matching a noncopyable value moves the value. Continuing with the account example, this code would be invalid:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> account &#123; <br>    Account &#123; name, language, .. &#125; =&gt; &#123; <br>        ui.<span class="hljs-title function_ invoke__">greet</span>(&amp;name, &amp;language); <br>        ui.<span class="hljs-title function_ invoke__">show_settings</span>(&amp;account); <span class="hljs-comment">// error: borrow of moved value: `account` </span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Suppose <code>name</code> and <code>language</code> are Strings. What can we do?</p>
</blockquote>
<p>We need a kind of pattern that <strong>borrows</strong> matched values instead of moving them. The ref keyword does just that:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> account &#123; <br>    Account &#123; <span class="hljs-keyword">ref</span> name, <span class="hljs-keyword">ref</span> language, .. &#125; =&gt; &#123; <br>        ui.<span class="hljs-title function_ invoke__">greet</span>(name, language); <br>        ui.<span class="hljs-title function_ invoke__">show_settings</span>(&amp;account); <span class="hljs-comment">// ok </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>You can use <code>ref mut</code> to borrow mut references:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> line_result &#123; <br>    <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-keyword">ref</span> err) =&gt; <span class="hljs-title function_ invoke__">log_error</span>(err), <span class="hljs-comment">// `err` is &amp;Error (shared ref) </span><br>    <span class="hljs-title function_ invoke__">Ok</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> line) =&gt; &#123;           <span class="hljs-comment">// `line` is &amp;mut String (mut ref) </span><br>        <span class="hljs-title function_ invoke__">trim_comments</span>(line);        <span class="hljs-comment">// modify the String in place </span><br>        <span class="hljs-title function_ invoke__">handle</span>(line); <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>A pattern starting with <code>&amp;</code> matches a reference:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> sphere.<span class="hljs-title function_ invoke__">center</span>() &#123; <br>    &amp;Point3d &#123; x, y, z &#125; =&gt; ... <br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>In an expression, <code>&amp;</code> creates a reference. In a pattern, <code>&amp;</code> matches a reference.</p>
</blockquote>
<h4 id="Match-Guards">Match Guards</h4>
<p>This doesn’t work as expected:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">check_move</span>(current_hex: Hex, click: Point) <span class="hljs-punctuation">-&gt;</span> game::<span class="hljs-type">Result</span>&lt;Hex&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">point_to_hex</span>(click) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;That&#x27;s not a game space.&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(current_hex) =&gt;<br>        <span class="hljs-comment">// try to match if user clicked the current_hex</span><br>        <span class="hljs-comment">// (it doesn&#x27;t work: see explanation below)</span><br>        &#123;<br>            <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;You are already there! You must click somewhere else.&quot;</span>)<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Some</span>(other_hex) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(other_hex),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>This fails because identifiers in patterns introduce new variables.</p>
<p>One way to fix this is simply to use an if expression in the match arm:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">check_move</span>(current_hex: Hex, click: Point) <span class="hljs-punctuation">-&gt;</span> game::<span class="hljs-type">Result</span>&lt;Hex&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">point_to_hex</span>(click) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;That&#x27;s not a game space.&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(hex) =&gt; &#123;<br>            <span class="hljs-keyword">if</span> hex == current_hex &#123;<br>                <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;You are already there! You must click somewhere else&quot;</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(hex)<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>But Rust also provides <strong>match guards</strong>, extra conditions that must be true in order for a match arm to apply:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">check_move</span>(current_hex: Hex, click: Point) <span class="hljs-punctuation">-&gt;</span> game::<span class="hljs-type">Result</span>&lt;Hex&gt; &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">point_to_hex</span>(click) &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;That&#x27;s not a game space.&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(hex) <span class="hljs-keyword">if</span> hex == current_hex =&gt; &#123;<br>            <span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;You are already there! You must click somewhere else&quot;</span>)<br>        &#125;<br>        <span class="hljs-title function_ invoke__">Some</span>(hex) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(hex),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The vertical bar (<code>|</code>) can be used to combine several patterns in a single match arm:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">at_end</span> = <span class="hljs-keyword">match</span> chars.<span class="hljs-title function_ invoke__">peek</span>() &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">&#x27;\r&#x27;</span>) | <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">&#x27;\n&#x27;</span>) | <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">true</span>, <br>    _ =&gt; <span class="hljs-literal">false</span>, <br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="Chapter-11-Traits-and-Generics">Chapter 11 Traits and Generics</h2>
<h3 id="Traits">Traits</h3>
<p>There is one unusual rule about trait methods: the trait itself must be in scope. Otherwise, all its methods are hidden:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt; = <span class="hljs-built_in">vec!</span>[]; <br>buf.<span class="hljs-title function_ invoke__">write_all</span>(<span class="hljs-string">b&quot;hello&quot;</span>)?; <span class="hljs-comment">// error: no method named `write_all`</span><br></code></pre></td></tr></table></figure>
<p>Instead, you can write:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Write; <br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt; = <span class="hljs-built_in">vec!</span>[]; <br>buf.<span class="hljs-title function_ invoke__">write_all</span>(<span class="hljs-string">b&quot;hello&quot;</span>)?; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
<h4 id="Trait-Objects">Trait Objects</h4>
<p>There are two ways of using traits to write polymorphic code in Rust:</p>
<ul>
<li>Trait objects</li>
<li>Generics</li>
</ul>
<p>This doesn’t work:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::Write; <br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt; = <span class="hljs-built_in">vec!</span>[]; <br><span class="hljs-keyword">let</span> <span class="hljs-variable">writer</span>: <span class="hljs-keyword">dyn</span> Write = buf; <span class="hljs-comment">// error: `Write` does not have a constant size</span><br></code></pre></td></tr></table></figure>
<p>A variable’s size has to be known at compile time, and types that implement Write can be any size.</p>
<blockquote>
<p>In Java, a variable of type OutputStream (the Java standard interface analogous to std::io::Write) is a reference to any object that implements OutputStream. The fact that it’s a reference goes without saying.</p>
</blockquote>
<p>What we want in Rust is the same thing, but in Rust, references are explicit:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">u8</span>&gt; = <span class="hljs-built_in">vec!</span>[]; <br><span class="hljs-keyword">let</span> <span class="hljs-variable">writer</span>: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Write = &amp;<span class="hljs-keyword">mut</span> buf; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
<p>A reference to a trait type, like <code>writer</code>, is called a <em><strong>trait object</strong></em>.</p>
<p>In memory, a trait object is a fat pointer consisting of a pointer to the value, plus a pointer to a table representing that value’s type. Each trait object therefore takes up two machine words:</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240207104118126.png" alt="image-20240207104118126"></p>
<h4 id="Generic-Functions-and-Type-Parameters">Generic Functions and Type Parameters</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>(out: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> Write) <span class="hljs-comment">// plain function </span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">say_hello</span>&lt;W: Write&gt;(out: &amp;<span class="hljs-keyword">mut</span> W) <span class="hljs-comment">// generic function</span><br></code></pre></td></tr></table></figure>
<h4 id="Self-in-Traits">Self in Traits</h4>
<p>A trait can use the keyword <code>Self</code> as a type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Clone</span> &#123; <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>; <br>    ... <br>&#125;<br></code></pre></td></tr></table></figure>
<p>A trait that uses the <code>Self</code> type is <em><strong>incompatible</strong></em> with trait objects:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// error: the trait `Spliceable` cannot be made into an object </span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">splice_anything</span>(left: &amp;<span class="hljs-keyword">dyn</span> Spliceable, right: &amp;<span class="hljs-keyword">dyn</span> Spliceable) &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">combo</span> = left.<span class="hljs-title function_ invoke__">splice</span>(right); <br>    <span class="hljs-comment">// ... </span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Subtraits">Subtraits</h4>
<p>We can declare that a trait is an extension of another trait:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Someone in the game world, either the player or some other </span><br><span class="hljs-comment">/// pixie, gargoyle, squirrel, ogre, etc. </span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Creature</span>: Visible &#123; <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">position</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>); <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">facing</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Direction; <br>    ... <br>&#125;<br></code></pre></td></tr></table></figure>
<p>The phrase trait <code>Creature: Visible</code> means that all creatures are visible. Every type that implements <code>Creature</code> must also implement the <code>Visible</code> trait.</p>
<h4 id="Associated-Types">Associated Types</h4>
<p>Rust has a standard <code>Iterator</code> trait, defined like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123; <br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>; <br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The first feature of this trait, <code>type Item;</code>, is an associated type. Each type that implements Iterator must specify what type of item it produces.</p>
<p>Here’s what it looks like to implement Iterator for a type:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// (code from the std::env standard library module) </span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Args</span> &#123; <br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">String</span>; <br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; &#123; ... &#125; <br>    ... <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dump</span>(iter: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">dyn</span> <span class="hljs-built_in">Iterator</span>&lt;Item = <span class="hljs-type">String</span>&gt;) &#123;<br>    <span class="hljs-keyword">for</span> (index, s) <span class="hljs-keyword">in</span> iter.<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;:?&#125;&quot;</span>, index, s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Chapter-13-Utility-Traits">Chapter 13 Utility Traits</h2>
<h3 id="Deref-and-DerefMut">Deref and DerefMut</h3>
<p>Pointer types like <code>Box&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> implement these traits so that they can behave as Rust’s built-in pointer types do.</p>
<p>The traits are defined like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123; <br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>; <br>    <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target; <br>&#125; <br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">DerefMut</span>: Deref &#123; <br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>::Target; <br>&#125;<br></code></pre></td></tr></table></figure>
<p>The <code>deref</code> and <code>deref_mut</code> methods take a <code>&amp;Self</code> reference and return a <code>&amp;Self::Target</code> reference. <code>Target</code> should be something that <code>Self</code> contains, owns, or refers to: for <code>Box&lt;Complex&gt;</code> the <code>Target</code> type is <code>Complex</code>.</p>
<h2 id="Chapter-14-Closures">Chapter 14 Closures</h2>
<h3 id="Capturing-Variables">Capturing Variables</h3>
<h4 id="Closures-That-Borrow">Closures That Borrow</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Sort by any of several different statistics. </span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">sort_by_statistic</span>(cities: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;City&gt;, stat: Statistic) &#123; <br>    cities.<span class="hljs-title function_ invoke__">sort_by_key</span>(|city| -city.<span class="hljs-title function_ invoke__">get_statistic</span>(stat)); <br>&#125;<br></code></pre></td></tr></table></figure>
<p>In this case, when Rust creates the closure, it automatically borrows a reference to stat.</p>
<p>Since the closure contains a reference to stat, Rust won’t let it outlive stat. Since the closure is only used during sorting, this example is fine.</p>
<h4 id="Closures-That-Steal">Closures That Steal</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread; <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_sorting_thread</span>(<span class="hljs-keyword">mut</span> cities: <span class="hljs-type">Vec</span>&lt;City&gt;, stat: Statistic) <br>    <span class="hljs-punctuation">-&gt;</span> thread::JoinHandle&lt;<span class="hljs-type">Vec</span>&lt;City&gt;&gt; &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">key_fn</span> = |city: &amp;City| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i64</span> &#123; -city.<span class="hljs-title function_ invoke__">get_statistic</span>(stat) &#125;; <br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123; <br>        cities.<span class="hljs-title function_ invoke__">sort_by_key</span>(key_fn); <br>        cities <br>    &#125;) <br>&#125;<br></code></pre></td></tr></table></figure>
<p>Rust will reject this program because “closure may outlive the current function, but it borrows <code>stat</code>, which is owned by the current function”.</p>
<p>Tell Rust to <em><strong>move</strong></em> cities and stat into the closures that use them instead of borrowing references to them.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_sorting_thread</span>(<span class="hljs-keyword">mut</span> cities: <span class="hljs-type">Vec</span>&lt;City&gt;, stat: Statistic) <br>    <span class="hljs-punctuation">-&gt;</span> thread::JoinHandle&lt;<span class="hljs-type">Vec</span>&lt;City&gt;&gt; &#123; <br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">key_fn</span> = <span class="hljs-keyword">move</span> |city: &amp;City| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i64</span> &#123; -city.<span class="hljs-title function_ invoke__">get_statistic</span>(stat) &#125;; <br>        thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123; <br>            cities.<span class="hljs-title function_ invoke__">sort_by_key</span>(key_fn); <br>            cities <br>        &#125;) <br>&#125;<br></code></pre></td></tr></table></figure>
<p>The <code>move</code> keyword tells Rust that a closure doesn’t borrow the variables it uses: it steals them.</p>
<p>Rust thus offers two ways for closures to get data from enclosing scopes: moves and borrowing. A few case in point:</p>
<ul>
<li>Just as everywhere else in the language, if a closure would move a value of a copyable type, like i 32, it copies the value instead.</li>
<li>Values of noncopyable types, like <code>Vec&lt;City&gt;</code>, really are moved: the preceding code transfers cities to the new thread, by way of the <em><strong>move</strong></em> closure.</li>
</ul>
<blockquote>
<p>We get something important by accepting Rust’s strict rules: thread safety. It is precisely because the vector is moved, rather than being shared across threads, that we know the old thread won’t free the vector while the new thread is modifying it.</p>
</blockquote>
<h3 id="Function-and-Closure-Types">Function and Closure Types</h3>
<p>A function can take another function as an argument.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// Given a list of cities and a test function, </span><br><span class="hljs-comment">/// return how many cities pass the test. </span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">count_selected_cities</span>(cities: &amp;<span class="hljs-type">Vec</span>&lt;City&gt;, <br>                        test_fn: <span class="hljs-title function_ invoke__">fn</span>(&amp;City) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">city</span> <span class="hljs-keyword">in</span> cities &#123; <br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">test_fn</span>(city) &#123; <br>            count += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    count<br>&#125;<br><br><span class="hljs-comment">/// An example of a test function. Note that the type of </span><br><span class="hljs-comment">/// this function is `fn(&amp;City) -&gt; bool`, the same as /// the `test_fn` argument to `count_selected_cities`. </span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">has_monster_attacks</span>(city: &amp;City) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; <br>    city.monster_attack_risk &gt; <span class="hljs-number">0.0</span> <br>&#125; <br><br><span class="hljs-comment">// How many cities are at risk for monster attack? </span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-title function_ invoke__">count_selected_cities</span>(&amp;my_cities, has_monster_attacks);<br></code></pre></td></tr></table></figure>
<p>After all this, it may come as a surprise that <em><strong>closures do not have the same type as functions</strong></em>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-title function_ invoke__">count_selected_cities</span>( <br> &amp;my_cities, <br> |city| city.monster_attack_risk &gt; limit); <span class="hljs-comment">// error: type mismatch</span><br></code></pre></td></tr></table></figure>
<p>To support closures, we must change the type signature of this function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">count_selected_cities</span>&lt;F&gt;(cities: &amp;<span class="hljs-type">Vec</span>&lt;City&gt;, test_fn: F) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> <br>    <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>(&amp;City) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">count</span> = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">city</span> <span class="hljs-keyword">in</span> cities &#123; <br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_ invoke__">test_fn</span>(city) &#123; <br>            count += <span class="hljs-number">1</span>; <br>        &#125; <br>    &#125; <br>    count <br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-title function_ invoke__">fn</span>(&amp;City) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> <span class="hljs-comment">// fn type (functions only) </span><br><span class="hljs-title function_ invoke__">Fn</span>(&amp;City) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> <span class="hljs-comment">// Fn trait (both functions and closures)</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>In fact, every closure you write has its own type, because a closure may contain data: values either borrowed or stolen from enclosing scopes. This could be any number of variables, in any combination of types. <em><strong>So every closure has an ad hoc type created by the compiler, large enough to hold that data.</strong></em></p>
</blockquote>
<h3 id="Closures-and-Safety">Closures and Safety</h3>
<h4 id="Closures-That-Kill">Closures That Kill</h4>
<p><em><strong>A closure that can be called only once</strong></em> may seem like a rather extraordinary thing, but we’ve been talking throughout this book about ownership and lifetimes. The idea of values being used up (that is, moved) is one of the core concepts in Rust. It works the same with closures as with everything else.</p>
<h4 id="FnOnce">FnOnce</h4>
<p>Closures that drop values implement a less powerful trait, <code>FnOnce</code>, <em><strong>the trait of closures that can be called once</strong></em>.</p>
<p>The first time you call a <code>FnOnce</code> closure, <em><strong>the closure itself is used up</strong></em>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Pseudocode for `Fn` and `FnOnce` traits with no arguments. </span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Fn</span>() <span class="hljs-punctuation">-&gt;</span> R &#123; <br> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> R; <br>&#125; <br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">FnOnce</span>() <span class="hljs-punctuation">-&gt;</span> R &#123; <br> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_once</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> R; <br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="FnMut">FnMut</h4>
<p>There is one more kind of closure, the kind that contains mutable data or <code>mut</code> references.</p>
<p>Rust considers non-mut values safe to share across threads. But it wouldn’t be safe to share non-mut closures that contain <code>mut</code> data: calling such a closure from multiple threads could lead to all sorts of race conditions as multiple threads try to read and write the same data at the same time.</p>
<p><code>FnMut</code> closures are called by mut reference:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">FnMut</span>() <span class="hljs-punctuation">-&gt;</span> R &#123; <br> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> R; <br>&#125;<br></code></pre></td></tr></table></figure>
<p><em><strong>Any closure that requires mut access to a value, but doesn’t drop any values, is an <code>FnMut</code> closure.</strong></em></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">let</span> <span class="hljs-variable">incr</span> = || &#123; <br> i += <span class="hljs-number">1</span>; <span class="hljs-comment">// incr borrows a mut reference to i </span><br> <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Ding! i is now: &#123;&#125;&quot;</span>, i); <br>&#125;; <br><span class="hljs-title function_ invoke__">call_twice</span>(incr);<br></code></pre></td></tr></table></figure>
<p>A summary:</p>
<ul>
<li><code>Fn</code> is the family of closures and functions that you can call multiple times without restriction. This highest category also includes all fn functions.</li>
<li><code>FnMut</code> is the family of closures that can be called multiple times if the closure itself is declared mut.</li>
<li><code>FnOnce</code> is the family of closures that can be called once, if the caller owns the closure.</li>
</ul>
<p>Every <code>Fn</code> meets the requirements for <code>FnMut</code>, and every <code>FnMut</code> meets the requirements for <code>FnOnce</code>.</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240209184800948.png" alt="image-20240209184800948"></p>
<h4 id="Copy-and-Clone-for-Closures">Copy and Clone for Closures</h4>
<p>The rules for <code>Copy</code> and <code>Clone</code> on closures are just like the <code>Copy</code> and <code>Clone</code> rules for regular structs:</p>
<ul>
<li>A non-move closure that doesn’t mutate variables holds only shared references, which are both <code>Clone</code> and <code>Copy</code>, so that closure is both <code>Clone</code> and <code>Copy</code> as well.</li>
<li>A non-move closure that <em><strong>does</strong></em> mutate values has mutable references within its internal representation. Mutable references are neither <code>Clone</code> nor <code>Copy</code>, so neither is a closure that uses them.</li>
<li>For a <em><strong>move</strong></em> closure, the rules are even simpler. If everything a move closure captures is <code>Copy</code>, it’s <code>Copy</code>. If everything it captures is <code>Clone</code>, it’s <code>Clone</code>.</li>
</ul>
<h2 id="Chapter-15-Iterators">Chapter 15 Iterators</h2>
<p>An <em><strong>iterator</strong></em> is a value that produces a sequence of values, typically for a loop to operate on.</p>
<p>here’s some terminology for iterators:</p>
<ul>
<li>An iterator is any type that implements <code>Iterator</code>.</li>
<li>An iterable is any type that implements <code>IntoIterator</code>: you can get an iterator over it by calling its <code>into_iter</code> method.
<ul>
<li>The vector reference &amp;v is the iterable in this case.</li>
</ul>
</li>
<li>An iterator produces values.</li>
<li>The values an iterator produces are <code>items</code>.</li>
<li>The code that receives the items an iterator produces is the consumer.</li>
</ul>
<h3 id="Creating-Iterators">Creating Iterators</h3>
<p>Most collection types provide <code>iter</code> and <code>iter_mut</code> methods that return the natural iterators over the type, <em><strong>producing a shared or mutable reference to each item</strong></em>.</p>
<h4 id="IntoIterator-Implementations">IntoIterator Implementations</h4>
<p>When a type implements IntoIterator, you can call its into_iter method yourself, just as a for loop would.</p>
<p>Most collections actually provide several implementations of IntoIterator, for shared references (&amp;T), mutable references (&amp;mut T), and moves (T):</p>
<ul>
<li>Given a shared reference to the collection, <code>into_iter</code> returns an iterator that produces shared references to its items. For example, in the preceding code, (&amp;favorites).into_iter() would return an iterator whose Item type is <code>&amp;String</code>.</li>
<li>Given a mutable reference to the collection, <code>into_iter</code> returns an iterator that produces mutable references to the items. For example, if vector is some <code>Vec&lt;String&gt;</code>, the call <code>(&amp;mut vector).into_iter()</code> returns an iterator whose Item type is <code>&amp;mut String</code>.</li>
<li>When passed the collection by value, into_iter returns an iterator that takes ownership of the collection and returns items by value; the items’ ownership moves from the collection to the consumer, and the original collection is consumed in the process. For example, the call <code>favorites.into_iter()</code> in the preceding code returns an iterator that produces each string by value; the consumer receives ownership of each string. When the iterator is dropped, any elements remaining in the BTreeSet are dropped too, and the set’s now-empty husk is disposed of.</li>
</ul>
<p>Just like:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> &amp;collection &#123; ... &#125; <br><span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> collection &#123; ... &#125; <br><span class="hljs-keyword">for</span> <span class="hljs-variable">element</span> <span class="hljs-keyword">in</span> collection &#123; ... &#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>IntoIterator</code> is what makes <code>for</code> loops work, so that’s obviously necessary. But when you’re not using a for loop, it’s clearer to write <code>favorites.iter()</code> than <code>(&amp;favorites).into_iter()</code>. Iteration by shared reference is something you’ll need frequently, so iter and iter_mut are still valuable for their ergonomics.</p>
</blockquote>
<p><code>IntoIterator</code> can also be useful in generic code: you can use a bound like <code>T: IntoIterator</code> to restrict the type variable <code>T</code> to types that can be iterated over. Or, you can write <code>T: IntoIterator&lt;Item=U&gt;</code> to further require the iteration to produce a particular type <code>U</code>.</p>
<h2 id="Chapter-18-Collections">Chapter 18 Collections</h2>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240210111243798.png" alt="image-20240210111243798"></p>
<h3 id="Vec-T"><code>Vec&lt;T&gt;</code></h3>
<h2 id="Chapter-18-Input-and-Output">Chapter 18 Input and Output</h2>
<p>Rust’s standard library features for input and output are organized around three traits, <code>Read</code>, <code>BufRead</code>, and <code>Write</code>:</p>
<ul>
<li>Values that implement <code>Read</code> have methods <em><strong>for byte-oriented input</strong></em>. They’re called <em><strong>readers</strong></em>.</li>
<li>Values that implement <code>BufRead</code> are buffered readers. <em><strong>They support all the methods of <code>Read</code>, plus methods for reading lines of text and so forth</strong></em>.</li>
<li>Values that implement <code>Write</code> support both byte-oriented and UTF-8 text output. They’re called <em><strong>writers</strong></em>.</li>
</ul>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240210112953117.png" alt="image-20240210112953117"></p>
<h3 id="Readers-and-Writers">Readers and Writers</h3>
<h4 id="Reader">Reader</h4>
<p><code>std::io::Read</code> has several methods for reading data. All of them take the reader itself by <code>mut</code> reference.</p>
<ul>
<li><code>reader.read(&amp;mut buffer)</code>
<ul>
<li>Reads some bytes from the data source and stores them in the given <code>buffer</code>.</li>
</ul>
</li>
<li><code>reader.read_to_end(&amp;mut byte_vec)</code>
<ul>
<li>Reads all remaining input from this reader, appending it to <code>byte_vec</code>, which is a <code>Vec&lt;u8&gt;</code>.</li>
</ul>
</li>
<li><code>reader.read_to_string(&amp;mut string)</code>
<ul>
<li>This is the same, but appends the data to the given <code>String</code>.</li>
</ul>
</li>
<li><code>reader.read_exact(&amp;mut buf)</code>
<ul>
<li>Reads exactly enough data to fill the given buffer. If the reader runs out of data before reading <code>buf.len()</code> bytes, this returns an error.</li>
</ul>
</li>
</ul>
<h3 id="Buffered-Readers">Buffered Readers</h3>
<ul>
<li><code>reader.read_line(&amp;mut line)</code>
<ul>
<li>Reads a line of text and appends it to line, which is a <code>String</code>.</li>
</ul>
</li>
<li><code>reader.lines()</code>
<ul>
<li>Returns an iterator over the lines of the input.</li>
</ul>
</li>
</ul>
<h2 id="Chapter-19-Concurrency">Chapter 19 Concurrency</h2>
<h3 id="Fork-Join-Parallelism">Fork-Join Parallelism</h3>
<h4 id="spawn-and-join">spawn and join</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;io, thread&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_files_in_parallel</span>(filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Divide the work into several chunks.</span><br>    <span class="hljs-keyword">const</span> NTHREADS: <span class="hljs-type">usize</span> = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">worklists</span> = <span class="hljs-title function_ invoke__">split_vec_into_chunks</span>(filenames, NTHREADS);<br><br>    <span class="hljs-comment">// Fork: Spawn a thread to handle each chunk.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">thread_handles</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">worklist</span> <span class="hljs-keyword">in</span> worklists &#123;<br>        thread_handles.<span class="hljs-title function_ invoke__">push</span>(thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || <span class="hljs-title function_ invoke__">process_files</span>(worklist)));<br>    &#125; <span class="hljs-comment">// Join: Wait for all threads to finish.</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> thread_handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>()?;<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="Sharing-Immutable-Data-Across-Threads">Sharing Immutable Data Across Threads</h4>
<p><code>spawn</code> launches independent threads. Rust has no way of knowing how long the child thread will run, so it assumes the worst: it assumes the child thread may keep running even after the parent thread has finished and all values in the parent thread are gone.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc; <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">process_files_in_parallel</span>(filenames: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;, <br>                        glossary: Arc&lt;GigabyteMap&gt;) <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123; <br>    ... <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">worklist</span> <span class="hljs-keyword">in</span> worklists &#123; <br>        <span class="hljs-comment">// This call to .clone() only clones the Arc and bumps the </span><br>        <span class="hljs-comment">// reference count. It does not clone the GigabyteMap. </span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">glossary_for_child</span> = glossary.<span class="hljs-title function_ invoke__">clone</span>(); <br>        thread_handles.<span class="hljs-title function_ invoke__">push</span>( <br>                <span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || <span class="hljs-title function_ invoke__">process_files</span>(worklist, &amp;glossary_for_child)) <br>                ); <br>    &#125; <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>As long as <em><strong>any</strong></em> thread owns an <code>Arc&lt;GigabyteMap&gt;</code>, it will keep the map alive, even if the parent thread bails out early. There won’t be any data races, because data in an <code>Arc</code> is immutable.</p>
<h3 id="Channels">Channels</h3>
<p>A <em><strong>channel</strong></em> is a one-way conduit for sending values from one thread to another. In other words, it’s a thread-safe queue.</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20240210120702288.png" alt="image-20240210120702288"></p>
<h4 id="Thread-Safety-Send-and-Sync">Thread Safety: Send and Sync</h4>
<p>Rust’s full thread safety story hinges on two built-in traits, <code>std::marker::Send</code> and <code>std::marker::Sync</code>.</p>
<ul>
<li>Types that implement <code>Send</code> are safe to pass by value to another thread. They can be moved across threads.</li>
<li>Types that implement <code>Sync</code> are safe to pass by non-mut reference to another thread. They can be shared across threads.</li>
</ul>
<blockquote>
<p>By <em><strong>safe</strong></em> here, we mean the same thing we always mean: free from data races and other undefined behavior.</p>
</blockquote>
<p>A struct or enum is <code>Send</code> if its fields are <code>Send</code>, and <code>Sync</code> if its fields are <code>Sync</code>.</p>
<h3 id="Shared-Mutable-State">Shared Mutable State</h3>
<blockquote>
<p>In C++, as in most languages, the data and the lock are separate objects. Ideally, comments explain that every thread must acquire the mutex before touching the data.</p>
</blockquote>
<p>Unlike C++, in Rust the protected data is stored inside the Mutex. Setting up the Mutex looks like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc; <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">app</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(FernEmpireApp &#123; <br>    ...<br>     waiting_list: Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[]), <br>     ... <br> &#125;);<br></code></pre></td></tr></table></figure>
<p><code>Arc</code> is handy for sharing things across threads, and <code>Mutex</code> is handy for mutable data that’s shared across threads.</p>
<p>The only way to get at the data is to call the <code>.lock()</code> method:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guard</span> = <span class="hljs-keyword">self</span>.waiting_list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
<h4 id="mut-and-Mutex">mut and Mutex</h4>
<p>In Rust, <code>&amp;mut</code> <em><strong>means exclusive access</strong></em>. Plain <code>&amp;</code> means <em><strong>shared access</strong></em>.</p>
<p><code>Mutex</code> does have a way: the lock. In fact, a mutex is little more than a way to do exactly this, to provide <em><strong>exclusive</strong></em> (<code>mut</code>) access to the data inside, even though many threads may have <em><strong>shared</strong></em> (<code>non-mut</code>) access to the <code>Mutex</code> itself.</p>
<p>If a thread panics while holding a <code>Mutex</code>, Rust marks the Mutex as <em><strong>poisoned</strong></em>. Any subsequent attempt to lock the poisoned Mutex will get an error result. But you <em><strong>can</strong></em> still lock a poisoned mutex and access the data inside, with mutual exclusion fully enforced; see the documentation for <code>PoisonError::into_inner()</code>. But you won’t do it by accident.</p>
<h4 id="Condition-Variables-Condvar">Condition Variables (Condvar)</h4>
<p>A Condvar has methods <code>.wait()</code> and <code>.notify_all()</code>; <code>.wait()</code> blocks until some other thread calls <code>.notify_all()</code>.</p>
<h2 id="Chapter-20-Asynchronous-Programming">Chapter 20 Asynchronous Programming</h2>
<p>You can use Rust <em><strong>asynchronous tasks</strong></em> to interleave many independent activities on a single thread or a pool of worker threads. Asynchronous tasks are similar to threads, but are much quicker to create, pass control amongst themselves more efficiently, and have memory overhead an order of magnitude less than that of a thread.</p>
<p>It is perfectly feasible to have hundreds of thousands of asynchronous tasks running simultaneously in a single program.</p>
<p>Before:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::&#123;net, thread&#125;; <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = net::TcpListener::<span class="hljs-title function_ invoke__">bind</span>(address)?; <br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">socket_result</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">socket</span> = socket_result?; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">groups</span> = chat_group_table.<span class="hljs-title function_ invoke__">clone</span>(); <br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123; <br>        <span class="hljs-title function_ invoke__">log_error</span>(<span class="hljs-title function_ invoke__">serve</span>(socket, groups)); <br>    &#125;); <br>&#125;<br></code></pre></td></tr></table></figure>
<p>After:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> async_std::&#123;net, task&#125;; <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = net::TcpListener::<span class="hljs-title function_ invoke__">bind</span>(address).<span class="hljs-keyword">await</span>?; <br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">new_connections</span> = listener.<span class="hljs-title function_ invoke__">incoming</span>(); <br><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(socket_result) = new_connections.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-keyword">await</span> &#123; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">socket</span> = socket_result?; <br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">groups</span> = chat_group_table.<span class="hljs-title function_ invoke__">clone</span>(); <br>    task::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> &#123; <br>        <span class="hljs-title function_ invoke__">log_error</span>(<span class="hljs-title function_ invoke__">serve</span>(socket, groups).<span class="hljs-keyword">await</span>); <br>    &#125;); <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="From-Synchronous-to-Asynchronous">From Synchronous to Asynchronous</h3>
<h4 id="Futures">Futures</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Future</span> &#123; <br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br>    <span class="hljs-comment">// For now, read `Pin&lt;&amp;mut Self&gt;` as `&amp;mut Self`. </span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">poll</span>(<span class="hljs-keyword">self</span>: Pin&lt;&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>&gt;, cx: &amp;<span class="hljs-keyword">mut</span> Context&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <br>                    <span class="hljs-punctuation">-&gt;</span> Poll&lt;<span class="hljs-keyword">Self</span>::Output&gt;; <br>&#125; <br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Poll</span>&lt;T&gt; &#123; <br>    <span class="hljs-title function_ invoke__">Ready</span>(T), <br>    Pending, <br>&#125;<br></code></pre></td></tr></table></figure>
<p>A future’s <code>poll</code> method never waits for the operation to finish: it always returns immediately.</p>
<p>If and when the future is worth polling again, it promises to let us know by invoking a waker, a callback function supplied in the Context. We call this the “piñata model” of asynchronous programming: the only thing you can do with a future is whack it with a poll until a value falls out.</p>
<hr>
<h2 id="Deref">Deref</h2>
<p>Rust 中引用既像指针，又不是那么的像指针：</p>
<ul>
<li>一方面 rust 中具有引用类型的变量的内存布局和 C 语言中的指针几乎是一样的</li>
<li>而另一方面，rust 中将“创建一个变量的引用”这种动作称呼为“借用这个变量”，<strong>同时我们的确可以隔着若干层变量的引用对一个变量进行操作</strong>
<ul>
<li>Rust 的方法解析时的自动借用/自动解引用机制</li>
</ul>
</li>
</ul>
<p>Rust 中，将一个方法调用(method call)的点号左侧的值称为&quot;方法的 receiver&quot;，而 rust 规定，在进行方法调用解析时，可以对 receiver 做以下的操作，来寻找合法的方法调用：</p>
<p>假设receiver具有类型<code>T</code>，重复执行以下操作直到<code>T</code>不再改变：</p>
<p>（1）使<code>U=T</code></p>
<p>（2）将<code>U</code>，<code>&amp;U</code>，<code>&amp;mut U</code>加入解析列表</p>
<p>（3）对<code>U</code>解引用，使<code>T=*U</code></p>
<p>上述循环结束后，执行一次 <a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/reference/type-coercions.html%23unsized-coercions">unsized coercion</a>，并使得 <code>T</code> 等于 unsized coercion 的得到的结果类型再次执行一次（2）和（3），最终得到一个完整的解析列表；最后，按顺序尝试将解析列表中的类型匹配到方法上，且最终的解析结果不能有冲突</p>
<p>用星号 <code>*</code> 操作符解引用时，实际执行的动作有两种情况：</p>
<ul>
<li>1.直接解引用：被解引用的表达式具有引用类型，那么就直接去掉一层 indirection</li>
<li>2.执行 <code>*(x.deref())</code>（来自 Deref Trait）：被解引用的表达式<strong>不具有引用类型</strong></li>
</ul>
<h3 id="Deref-Trait">Deref Trait</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>: ?<span class="hljs-built_in">Sized</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>)<span class="hljs-punctuation">-&gt;</span>&amp;<span class="hljs-keyword">Self</span>::Target; <span class="hljs-comment">//需要impl deref,返回一个类型为Target的引用</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于一个实现了Deref Trait的类型为<code>T</code>的表达式<code>x</code>来说，如果<code>Target=U</code>，那么：</p>
<ul>
<li><code>*x</code>等价于<code>*(x.deref())</code>：你从一个<code>T</code>得到一个<code>U</code> （x不是引用或者裸指针）</li>
<li>允许<code>&amp;T</code>类型，或者<code>&amp;mut T</code>的表达式被强转为<code>&amp;U</code>类型
<ul>
<li>因为<code>&amp;T</code>可以被转换(coerce)到<code>&amp;U</code>，<code>T</code>类型会自动实现所有<code>U</code>类型的不可变方法</li>
</ul>
</li>
</ul>
<blockquote>
<p>假设x是一个引用（也就是一个指针），*x的本意是得到指针类型指向的内存位置，即是一个具体的值</p>
<p>x.deref()获取到的是值的引用，和*的原意不一致，所以应该是*(x.deref())</p>
</blockquote>
<p>如果类型T实现了Deref(Target=U)和DerefMut(Target=U)，那么就相当于类型T自动实现了类型U的所有方法</p>
<p>因为Rust的自动借用/自动解引用机制：T会被解引用（通过执行*(T.deref()）来得到U</p>
<h2 id="Type-Coercions">Type Coercions</h2>
<p><strong>Type coercions</strong> are implicit operations that change the type of a value.</p>
<blockquote>
<p>Type Coercion包含了Deref Coercion</p>
<p><em>Deref coercion</em> converts a reference to a type that implements the <code>Deref</code> trait into a reference to another type.</p>
<p>Deref coercion is a convenience Rust <strong>performs on arguments</strong> to functions and methods.</p>
</blockquote>
<h3 id="Coercion-Sites">Coercion Sites</h3>
<p>Type Coercions会发生在程序的以下地方</p>
<ul>
<li>
<p><code>let</code> statements where an explicit type is given.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">_</span>: &amp;<span class="hljs-type">i8</span> = &amp;<span class="hljs-keyword">mut</span> <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Arguments for function and method calls</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">bar</span>(_: &amp;<span class="hljs-type">i8</span>) &#123; &#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">bar</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-number">42</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>针对的是Function和Method的<strong>参数</strong>（不包括调用方的处理）</p>
</blockquote>
</li>
</ul>
<h3 id="Rules">Rules</h3>
<p>Coercion is allowed between the following types:</p>
<ul>
<li>
<p><code>T</code> to <code>U</code> if <code>T</code> is a <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/subtyping.html">subtype</a> of <code>U</code> (<em>reflexive case</em>)</p>
</li>
<li>
<p><code>T_1</code> to <code>T_3</code> where <code>T_1</code> coerces to <code>T_2</code> and <code>T_2</code> coerces to <code>T_3</code> (<em>transitive case</em>)</p>
<p>Note that this is not fully supported yet.</p>
</li>
<li>
<p><code>&amp;mut T</code> to <code>&amp;T</code></p>
</li>
<li>
<p><code>*mut T</code> to <code>*const T</code></p>
</li>
<li>
<p><code>&amp;T</code> to <code>*const T</code></p>
</li>
<li>
<p><code>&amp;mut T</code> to <code>*mut T</code></p>
</li>
<li>
<p><code>&amp;T</code> or <code>&amp;mut T</code> to <code>&amp;U</code> if <code>T</code> implements <code>Deref&lt;Target = U&gt;</code>. For example:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CharContainer</span> &#123;<br>    value: <span class="hljs-type">char</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Deref</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">CharContainer</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = <span class="hljs-type">char</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">char</span> &#123;<br>        &amp;<span class="hljs-keyword">self</span>.value<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(arg: &amp;<span class="hljs-type">char</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = &amp;<span class="hljs-keyword">mut</span> CharContainer &#123; value: <span class="hljs-string">&#x27;y&#x27;</span> &#125;;<br>    <span class="hljs-title function_ invoke__">foo</span>(x); <span class="hljs-comment">//&amp;mut CharContainer is coerced to &amp;char.</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Differences-between-Deref-Coercion-and-Auto-dereferenced">Differences between Deref Coercion and Auto-dereferenced</h3>
<ul>
<li>发生的位置不一样
<ul>
<li>Deref Coercion只发生在Function或者Method的参数上</li>
<li>Auto-dereferenced发生在Method的调用方上</li>
</ul>
</li>
<li>结果不一样
<ul>
<li>Deref Coercion只会对Reference生效，并且一个reference经过Deref Coercion后仍然是一个reference（遵循特定的Rules）</li>
<li>Auto-dereferenced和Auto-referenced同时作用于Method的调用方，可能会产生reference，也可能会产生value</li>
</ul>
</li>
</ul>
<h2 id="Auto-referenced-Auto-dereferenced-with-Method">Auto-referenced &amp;&amp; Auto-dereferenced with Method</h2>
<blockquote>
<p>针对问题：为什么&amp;&amp;&amp;&amp;&amp;&amp;String或者&amp;String能够调用String的方法</p>
</blockquote>
<p>我们来分析一下Rust中Method到底是怎么执行的</p>
<p>通过method的第一个参数必须是self我们可以很清晰地察觉到method是如何转换为function的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">x.<span class="hljs-title function_ invoke__">method</span>() -<span class="hljs-punctuation">-&gt;</span> X::<span class="hljs-title function_ invoke__">method</span>(x)<br></code></pre></td></tr></table></figure>
<p>然后方法的第一参数分为两大类：</p>
<ul>
<li>self：自身，这样会发生所有权的转移</li>
<li>&amp;self：自身的引用，其中包括
<ul>
<li>&amp;self: immutable reference</li>
<li>&amp;mut self: mutable reference</li>
</ul>
</li>
</ul>
<p>在实际应用的过程中，Rust 会自动 ref 和自动 deref 来匹配合适的参数</p>
<p>这个过程叫做 <code>Method lookup</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">receiver.<span class="hljs-title function_ invoke__">method</span>(...)<br><span class="hljs-comment">// into</span><br>ReceiverType::<span class="hljs-title function_ invoke__">method</span>(<span class="hljs-title function_ invoke__">ADJ</span>(receiver), ...) <span class="hljs-comment">// for an inherent method call</span><br></code></pre></td></tr></table></figure>
<p>Method lookup包含两个阶段：</p>
<ul>
<li>Probing
<ul>
<li>Decide what method to call and how to adjust the receiver</li>
</ul>
</li>
<li>Confirmation
<ul>
<li>“applies” this selection, updating the side-tables, unifying type variables, and otherwise doing side-effectful things.</li>
</ul>
</li>
</ul>
<p>我们只关心 Probing 是怎么进行的</p>
<ol>
<li>生成所有可能的 receiver</li>
<li>生成所有可能的 method</li>
<li>将 receiver 和 method 进行匹配</li>
</ol>
<p>首先，probing 会通过对 receiver type 不断地解引用，生成一系列的 steps,直到不能再解引用为止，比如类型 <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> 会生成以下 step</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">Rc&lt;<span class="hljs-type">Box</span>&lt;[T; <span class="hljs-number">3</span>]&gt;&gt;<br><span class="hljs-type">Box</span>&lt;[T; <span class="hljs-number">3</span>]&gt;<br>[T; <span class="hljs-number">3</span>]<br>[T<br></code></pre></td></tr></table></figure>
<p>然后生成所有的method（这里忽略）</p>
<p>Finally, to actually pick the method, we will search down the steps, trying to match the receiver type against the candidate types.</p>
<p>在每一步中（假设该步的类型为U）：</p>
<ol>
<li>if there’s a method <code>bar</code> where the receiver type (the type of <code>self</code> in the method) matches <code>U</code> exactly</li>
<li>otherwise, add one auto-ref (take <code>&amp;</code> or <code>&amp;mut</code> of the receiver), and, if some method’s receiver matches <code>&amp;U</code></li>
</ol>
<p>Rust在进行方法解析时会发生自动借用/自动解引用</p>
<p>忙 Rust 中，将一个方法调用(method call)的点号左侧的值称为&quot;方法的 receiver&quot;，而 rust 规定，在进行方法调用解析时，可以对 receiver 做以下的操作，来寻找合法的方法调用：</p>
<p>假设receiver具有类型<code>T</code>，重复执行以下操作直到<code>T</code>不再改变：</p>
<p>（1）使<code>U=T</code></p>
<p>（2）将<code>U</code>，<code>&amp;U</code>，<code>&amp;mut U</code>加入解析列表</p>
<p>（3）对<code>U</code>解引用，使<code>T=*U</code></p>
<p>上述循环结束后，执行一次<a href="https://link.zhihu.com/?target=https%3A//doc.rust-lang.org/reference/type-coercions.html%23unsized-coercions">unsized coercion</a>，并使得<code>T</code>等于unsized coercion的得到的结果类型再次执行一次（2）和（3），最终得到一个完整的解析列表；最后，按顺序尝试将解析列表中的类型匹配到方法上，且最终的解析结果不能有冲突。</p>
<p>简单来说就是，每一步先分别试着加引用，以及加可变引用；如果不行，就对原来的类型解引用，反复尝试，直到解析成功。</p>
<h3 id="Example">Example</h3>
<p>Suppose we have a call <code>foo.refm()</code>, if <code>foo</code> has type:</p>
<ul>
<li><code>X</code>, then we start with <code>U = X</code>, <code>refm</code> has receiver type <code>&amp;...</code>, so step 1 doesn’t match, taking an auto-ref gives us <code>&amp;X</code>, and this does match (with <code>Self = X</code>), so the call is <code>RefM::refm(&amp;foo)</code></li>
<li><code>&amp;X</code>, starts with <code>U = &amp;X</code>, which matches <code>&amp;self</code> in the first step (with <code>Self = X</code>), and so the call is <code>RefM::refm(foo)</code></li>
<li><code>&amp;&amp;&amp;&amp;&amp;X</code>, this doesn’t match either step (the trait isn’t implemented for <code>&amp;&amp;&amp;&amp;X</code> or <code>&amp;&amp;&amp;&amp;&amp;X</code>), so we dereference once to get <code>U = &amp;&amp;&amp;&amp;X</code>, which matches 1 (with <code>Self = &amp;&amp;&amp;X</code>) and the call is <code>RefM::refm(*foo)</code></li>
<li><code>Z</code>, doesn’t match either step so it is dereferenced once, to get <code>Y</code>, which also doesn’t match, so it’s dereferenced again, to get <code>X</code>, which doesn’t match 1, but does match after auto-ref, so the call is <code>RefM::refm(&amp;**foo)</code>.</li>
<li><code>&amp;&amp;A</code>, the 1. doesn’t match and neither does 2. since the trait is not implemented for <code>&amp;A</code> (for 1) or <code>&amp;&amp;A</code> (for 2), so it is dereferenced to <code>&amp;A</code>, which matches 1., with <code>Self = A</code></li>
</ul>
<p>Suppose we have <code>foo.m()</code>, and that <code>A</code> isn’t <code>Copy</code>, if <code>foo</code> has type:</p>
<ul>
<li><code>A</code>, then <code>U = A</code> matches <code>self</code> directly so the call is <code>M::m(foo)</code> with <code>Self = A</code></li>
<li><code>&amp;A</code>, then 1. doesn’t match, and neither does 2. (neither <code>&amp;A</code> nor <code>&amp;&amp;A</code> implement the trait), so it is dereferenced to <code>A</code>, which does match, but <code>M::m(*foo)</code> requires taking <code>A</code> by value and hence moving out of <code>foo</code>, hence the error.</li>
<li><code>&amp;&amp;A</code>, 1. doesn’t match, but auto-ref gives <code>&amp;&amp;&amp;A</code>, which does match, so the call is <code>M::m(&amp;foo)</code> with <code>Self = &amp;&amp;&amp;A</code>.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123; val: <span class="hljs-type">i32</span> &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">std</span>::ops::Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = <span class="hljs-type">i32</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123; &amp;<span class="hljs-keyword">self</span>.val &#125;<br>&#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">M</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>); &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">i32</span>   &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32::m()&quot;</span>);  &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">X</span>     &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;X::m()&quot;</span>);    &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span> &amp;X    &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;X::m()&quot;</span>);   &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span> &amp;&amp;X   &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;&amp;X::m()&quot;</span>);  &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span> &amp;&amp;&amp;X  &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;&amp;&amp;X::m()&quot;</span>); &#125; &#125;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">RefM</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>); &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">i32</span>  &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i32::refm()&quot;</span>);  &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">X</span>    &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;X::refm()&quot;</span>);    &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span> &amp;X   &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;X::refm()&quot;</span>);   &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span> &amp;&amp;X  &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;&amp;X::refm()&quot;</span>);  &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span> &amp;&amp;&amp;X &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;&amp;&amp;X::refm()&quot;</span>); &#125; &#125;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Y</span> &#123; val: <span class="hljs-type">i32</span> &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">std</span>::ops::Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Y</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = <span class="hljs-type">i32</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123; &amp;<span class="hljs-keyword">self</span>.val &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Z</span> &#123; val: Y &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">std</span>::ops::Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Z</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = Y;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;Y &#123; &amp;<span class="hljs-keyword">self</span>.val &#125;<br>&#125;<br><br><br><span class="hljs-meta">#[derive(Clone, Copy)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span>    <span class="hljs-title class_">A</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A::m()&quot;</span>);    &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">M</span> <span class="hljs-keyword">for</span> &amp;&amp;&amp;A &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">m</span>(<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;&amp;&amp;A::m()&quot;</span>); &#125; &#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span>    <span class="hljs-title class_">A</span> &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A::refm()&quot;</span>);    &#125; &#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">RefM</span> <span class="hljs-keyword">for</span> &amp;&amp;&amp;A &#123; <span class="hljs-keyword">fn</span> <span class="hljs-title function_">refm</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&amp;&amp;&amp;A::refm()&quot;</span>); &#125; &#125;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// I&#x27;ll use @ to denote left side of the dot operator</span><br>    (*X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">m</span>();        <span class="hljs-comment">// i32::m()    , Self == @</span><br>    X&#123;val:<span class="hljs-number">42</span>&#125;.<span class="hljs-title function_ invoke__">m</span>();           <span class="hljs-comment">// X::m()      , Self == @</span><br>    (&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">m</span>();        <span class="hljs-comment">// &amp;X::m()     , Self == @</span><br>    (&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">m</span>();       <span class="hljs-comment">// &amp;&amp;X::m()    , Self == @</span><br>    (&amp;&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">m</span>();      <span class="hljs-comment">// &amp;&amp;&amp;X:m()    , Self == @</span><br>    (&amp;&amp;&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">m</span>();     <span class="hljs-comment">// &amp;&amp;&amp;X::m()   , Self == *@</span><br>    (&amp;&amp;&amp;&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">m</span>();    <span class="hljs-comment">// &amp;&amp;&amp;X::m()   , Self == **@</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br><br>    (*X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">refm</span>();     <span class="hljs-comment">// i32::refm() , Self == @</span><br>    X&#123;val:<span class="hljs-number">42</span>&#125;.<span class="hljs-title function_ invoke__">refm</span>();        <span class="hljs-comment">// X::refm()   , Self == &amp;@</span><br>    (&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">refm</span>();     <span class="hljs-comment">// X::refm()   , Self == @</span><br>    (&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">refm</span>();    <span class="hljs-comment">// &amp;X::refm()  , Self == @</span><br>    (&amp;&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">refm</span>();   <span class="hljs-comment">// &amp;&amp;X::refm() , Self == @</span><br>    (&amp;&amp;&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">refm</span>();  <span class="hljs-comment">// &amp;&amp;&amp;X::refm(), Self == @</span><br>    (&amp;&amp;&amp;&amp;&amp;X&#123;val:<span class="hljs-number">42</span>&#125;).<span class="hljs-title function_ invoke__">refm</span>(); <span class="hljs-comment">// &amp;&amp;&amp;X::refm(), Self == *@</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br><br>    Y&#123;val:<span class="hljs-number">42</span>&#125;.<span class="hljs-title function_ invoke__">refm</span>();        <span class="hljs-comment">// i32::refm() , Self == *@</span><br>    Z&#123;val:Y&#123;val:<span class="hljs-number">42</span>&#125;&#125;.<span class="hljs-title function_ invoke__">refm</span>(); <span class="hljs-comment">// i32::refm() , Self == **@</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;-------------------------&quot;</span>);<br><br>    A.<span class="hljs-title function_ invoke__">m</span>();                   <span class="hljs-comment">// A::m()      , Self == @</span><br>    <span class="hljs-comment">// without the Copy trait, (&amp;A).m() would be a compilation error:</span><br>    <span class="hljs-comment">// cannot move out of borrowed content</span><br>    (&amp;A).<span class="hljs-title function_ invoke__">m</span>();                <span class="hljs-comment">// A::m()      , Self == *@</span><br>    (&amp;&amp;A).<span class="hljs-title function_ invoke__">m</span>();               <span class="hljs-comment">// &amp;&amp;&amp;A::m()   , Self == &amp;@</span><br>    (&amp;&amp;&amp;A).<span class="hljs-title function_ invoke__">m</span>();              <span class="hljs-comment">// &amp;&amp;&amp;A::m()   , Self == @</span><br>    A.<span class="hljs-title function_ invoke__">refm</span>();                <span class="hljs-comment">// A::refm()   , Self == @</span><br>    (&amp;A).<span class="hljs-title function_ invoke__">refm</span>();             <span class="hljs-comment">// A::refm()   , Self == *@</span><br>    (&amp;&amp;A).<span class="hljs-title function_ invoke__">refm</span>();            <span class="hljs-comment">// A::refm()   , Self == **@</span><br>    (&amp;&amp;&amp;A).<span class="hljs-title function_ invoke__">refm</span>();           <span class="hljs-comment">// &amp;&amp;&amp;A::refm(), Self == @</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Summary">Summary</h3>
<h4 id="Method">Method</h4>
<p>Method是这样查找的</p>
<ul>
<li>如果如果方法签名类似于T::method(self)
<ul>
<li>方法左边就是T</li>
</ul>
</li>
<li>如果方法签名类似于T::method(&amp;self)
<ul>
<li>方法左边就是&amp;T</li>
</ul>
</li>
</ul>
<p>对于类型T，先让U=T</p>
<p>执行以下步骤</p>
<ul>
<li>查看U是否match</li>
<li>如果不match，查看&amp;U是否match</li>
</ul>
<p>U=*U（解引用一次）</p>
<p>再执行以上步骤</p>
<h3 id="Reference">Reference</h3>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28519997/what-are-rusts-exact-auto-dereferencing-rules">stackoverflow</a></p>
<p><strong>source code</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone,Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">PickAdjustment</span> &#123;<br>    <span class="hljs-comment">// Indicates that the source expression should be autoderef&#x27;d N times</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// A = expr | *expr | **expr</span><br>    <span class="hljs-title function_ invoke__">AutoDeref</span>(uint),<br><br>    <span class="hljs-comment">// Indicates that the source expression should be autoderef&#x27;d N</span><br>    <span class="hljs-comment">// times and then &quot;unsized&quot;. This should probably eventually go</span><br>    <span class="hljs-comment">// away in favor of just coercing method receivers.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// A = unsize(expr | *expr | **expr)</span><br>    <span class="hljs-title function_ invoke__">AutoUnsizeLength</span>(<span class="hljs-comment">/* number of autoderefs */</span> uint, <span class="hljs-comment">/* length*/</span> uint),<br><br>    <span class="hljs-comment">// Indicates that an autoref is applied after some number of other adjustments</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// A = &amp;A | &amp;mut A</span><br>    <span class="hljs-title function_ invoke__">AutoRef</span>(ast::Mutability, <span class="hljs-type">Box</span>&lt;PickAdjustment&gt;),<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Auto deref is part of coercion, which includes auto-deref, auto-unsize, auto-ref, etc.</p>
<p>See <a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/blob/b6d91a2bdac45cd919497a24207fab843124d4ba/src/librustc_typeck/check/method/probe.rs#L92">here</a></p>
</blockquote>
<h2 id="Ownership">Ownership</h2>
<p>一个变量如果拥有了某个值（不是引用），就代表该变量是这个值的 owner</p>
<p>If a variable wants to a value’s ownership:</p>
<ul>
<li>If the type of the value implements Copy Trait
<ul>
<li>A new value is copied from the old one, and the variable has the ownership</li>
</ul>
</li>
<li>If not
<ul>
<li>Just take over the ownership and make the old varialbe invalid</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个强盗索要你身上的一个东西，你要么拿个一模一样的给他（实现了Copy Trait），要么就直接把东西给他（move out）</p>
</blockquote>
<p>Rust有以下两种处理方式</p>
<ul>
<li>如果实现了Copy Trait，就在栈上复制出一份相同的新值，给新变量新值的ownership
<ul>
<li>该动作称为<code>Copy</code></li>
</ul>
</li>
<li>如果没有实现Copy Trait，把值的所有权交给新的变量，同时废除旧变量的ownership
<ul>
<li>该动作称为<code>Move Out</code></li>
</ul>
</li>
</ul>
<p>有两种情况新变量一个现有值的ownership：</p>
<ul>
<li>By assignment (<strong>Variable Binding</strong>)</li>
<li>By passing data through a function barrier
<ul>
<li>either as an argument or a return value</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_copy</span>(x:&amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>)&#123;<br>    <span class="hljs-comment">// y wants the ownership</span><br>    <span class="hljs-comment">// i32 implements the Copy Trait</span><br>    <span class="hljs-comment">// so make a copy</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = *x;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,y)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_move</span>(x:&amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;)&#123;<br>    <span class="hljs-comment">// y wants the ownership</span><br>    <span class="hljs-comment">// Option&lt;String&gt; doesn&#x27;t implement the Copy Trait</span><br>    <span class="hljs-comment">// so y will take over the ownership</span><br>    <span class="hljs-comment">// because x is a reference, it is not allowed</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = *x;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,y)<br><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-title function_ invoke__">test_copy</span>(&amp;<span class="hljs-keyword">mut</span> a);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;HELLO&quot;</span>));<br>    <span class="hljs-title function_ invoke__">test_move</span>(&amp;<span class="hljs-keyword">mut</span> b);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Lifetime">Lifetime</h2>
<p>The subject of the reference must live longer than the reference itself to keep the reference valid.</p>
<p>The borrow checker needs to know <strong>every</strong> reference’s lifetime.</p>
<ul>
<li>函数里的 lifetime specifier 相当于在显式地告诉 Borrow Checker 这个函数返回的引用的 lifetime 不应该比传入的两个引用中的任意一个长</li>
<li>结构体里面的 lifetime specifier 相当于在显式地告诉 Borrow Checker 这个结构体的 lifetime 不应该比结构体内部任意一个 reference 长</li>
</ul>
<p>只有你显式地告诉了 Borrow Checker 后，borrow checker 才能继续保证所有的 reference 都是有效的，不会出现悬垂引用的情况</p>
<h2 id="Option-T-take-Option-T-unwrap"><code>Option&lt;T&gt;.take()</code> &amp;&amp; <code>Option&lt;T&gt;.unwrap()</code></h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_mut</span>(a:&amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt;)&#123;<br>    <span class="hljs-comment">// when you are using unwrap(), you are expecting to unwrap the Option entity</span><br>    <span class="hljs-comment">// and diliver the inner content to someone</span><br>    <span class="hljs-comment">// So you have to take over the ownership and you don&#x27;t want to unwrap again to </span><br>    <span class="hljs-comment">// diliver the content to someone else, which violates the rule.</span><br>    <span class="hljs-comment">// let y = a.unwrap();</span><br>    <span class="hljs-comment">// Let&#x27;s exam the reason why it gives the Error</span><br>    <span class="hljs-comment">// &quot;cannot move out of `*a` which is behind a mutable reference&quot;</span><br>    <span class="hljs-comment">// a.unwrap() --&gt; Option::unwrap(*a)</span><br>    <span class="hljs-comment">// unwarp() wants the ownership</span><br>    <span class="hljs-comment">// the type (*a) Option&lt;String&gt; does not implement the &quot;Copy&quot; trait</span><br>    <span class="hljs-comment">// So it will take over the ownership</span><br>    <span class="hljs-comment">//But a:&amp;mut Option&lt;String&gt; is an reference, which does not have ownership</span><br>    <span class="hljs-comment">// So it gives the Error</span><br><br>    <span class="hljs-comment">// take() does not require the ownership, because it just changes the inner data,</span><br>    <span class="hljs-comment">// which is acceptable for a mut reference</span><br>    <span class="hljs-comment">// it changes the inner data to None and GIVE the origin Option&lt;String&gt; to someone</span><br>    <span class="hljs-comment">// GIVE means the receiver will have the ownership of the Option&lt;String&gt;</span><br>    <span class="hljs-comment">// take() is executing a replace operation at Enum level</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_y</span> = a.<span class="hljs-title function_ invoke__">take</span>();<br>&#125;<br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">x</span>  = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;HELLO&quot;</span>));<br>    <span class="hljs-title function_ invoke__">test_mut</span>(&amp;<span class="hljs-keyword">mut</span> x);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,x);<br>    <span class="hljs-comment">// let y = x.unwrap();</span><br>    <span class="hljs-comment">// println!(&quot;&#123;y&#125;&quot;);</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在一个结构体里面，结构体总是拥有它属下的值的所有权，在使用过程中，如果我们想要夺取某个值的所有权，可以预先把这个值用Option包裹一下，然后在需要所有权的地方调用take()方法</p>
<h2 id="Smart-Pointers">Smart Pointers</h2>
<h3 id="Box-T"><code>Box&lt;T&gt;</code></h3>
<p>Two main use cases for box</p>
<ul>
<li>
<p>When we have a variable with a trait type that can’t be computed at compile time</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drive</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Truck</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Vehicle</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Truck</span>&#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drive</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Truck is driving&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Vehicle&gt;;<br>    t= <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Truck);<br>    t.<span class="hljs-title function_ invoke__">drive</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li>
<p>Recursive data types</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Truck</span>&#123;<br>    next_truck:<span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Truck&gt;&gt;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Rc-T"><code>Rc&lt;T&gt;</code></h3>
<p>In  a situation where you want to have <strong>multiple reference</strong> of some memory but you’re not sure about the order in which those references are going to go out of scope and you want that memory wo stay around until the last reference goes out of scope.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Truck</span> &#123;<br>    capacity: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (truck_a, truck_b, truck_c) = (<br>        Rc::<span class="hljs-title function_ invoke__">new</span>(Truck &#123; capacity: <span class="hljs-number">1</span> &#125;),<br>        Rc::<span class="hljs-title function_ invoke__">new</span>(Truck &#123; capacity: <span class="hljs-number">2</span> &#125;),<br>        Rc::<span class="hljs-title function_ invoke__">new</span>(Truck &#123; capacity: <span class="hljs-number">3</span> &#125;),<br>    );<br><br>    <span class="hljs-comment">// Could get around this by using regular borrows</span><br>    <span class="hljs-comment">// assuming you only need a read-only reference to this</span><br>    <span class="hljs-comment">// Problem is that the main function has to maintain the ownership of truck_b</span><br>    <span class="hljs-comment">// track_b would get deallocated when the main function is done</span><br>    <span class="hljs-comment">// even if we stop needing truck_b long before that</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">facility_one</span> = <span class="hljs-built_in">vec!</span>[Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;truck_a), Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;truck_b)];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">facility_two</span> = <span class="hljs-built_in">vec!</span>[Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;truck_b), Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;truck_c)];<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;One &#123;:?&#125;&quot;</span>, facility_one);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Two &#123;:?&#125;&quot;</span>, facility_two);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Truck_b strong count &#123;&#125;&quot;</span>,Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;truck_b));<br>    std::mem::<span class="hljs-title function_ invoke__">drop</span>(facility_two);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;One after drop &#123;:?&#125;&quot;</span>, facility_one);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Truck_b strong count &#123;&#125;&quot;</span>,Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;truck_b));<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="ref">ref</h2>
<p>Bind by reference during pattern matching.</p>
<p><code>ref</code> annotates pattern bindings to make them borrow rather than move. It is <strong>not</strong> a part of the pattern as far as matching is concerned: it does not affect <em>whether</em> a value is matched, only <em>how</em> it is matched.</p>
<p>By default, <a href="vscode-file://vscode-app/usr/share/code/resources/app/out/vs/code/electron-sandbox/workbench/workbench.html"><code>match</code></a> statements consume all they can, which can sometimes be a problem, when you don’t really need the value to be moved and owned:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">maybe_name</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Alice&quot;</span>));<br>    <span class="hljs-comment">// The variable &#x27;maybe_name&#x27; is consumed here ...</span><br>    <span class="hljs-keyword">match</span> maybe_name &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(n) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;n&#125;&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>),<br>    &#125;<br>    <span class="hljs-comment">// ... and is now unavailable.</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello again, &#123;&#125;&quot;</span>, maybe_name.<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-string">&quot;world&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">maybe_name</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Alice&quot;</span>));<br>    <span class="hljs-comment">// Using `ref`, the value is borrowed, not moved ...</span><br>    <span class="hljs-keyword">match</span> maybe_name &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">ref</span> n) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, &#123;n&#125;&quot;</span>),<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>),<br>    &#125;<br>    <span class="hljs-comment">// ... so it&#x27;s available here!</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello again, &#123;&#125;&quot;</span>, maybe_name.<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-string">&quot;world&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()));<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>在tuple的结构中也常见</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tuple</span> = (<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1&quot;</span>), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;2&quot;</span>));<br>    <span class="hljs-comment">// variable a,b is moved from tuple</span><br>    <span class="hljs-keyword">let</span> (a, b) = tuple;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tuple2</span> = (<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1&quot;</span>), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;2&quot;</span>));<br><br>    <span class="hljs-comment">// variable c,d borrow from tuple2</span><br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">ref</span> c,<span class="hljs-keyword">ref</span> d)= tuple2;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, c, d);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,tuple2)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Copy-Clone">Copy &amp;&amp; Clone</h2>
<h3 id="Clone-Trait">Clone Trait</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Clone</span>: <span class="hljs-built_in">Sized</span> &#123;<br>    <span class="hljs-comment">/// Returns a copy of the value.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// # Examples</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// ```</span><br>    <span class="hljs-comment">/// # #![allow(noop_method_call)]</span><br>    <span class="hljs-comment">/// let hello = &quot;Hello&quot;; // &amp;str implements Clone</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// assert_eq!(&quot;Hello&quot;, hello.clone());</span><br>    <span class="hljs-comment">/// ```</span><br>    <span class="hljs-meta">#[stable(feature = <span class="hljs-string">&quot;rust1&quot;</span>, since = <span class="hljs-string">&quot;1.0.0&quot;</span>)]</span><br>    <span class="hljs-meta">#[must_use = <span class="hljs-string">&quot;cloning is often expensive and is not expected to have side effects&quot;</span>]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;<br><br>    <span class="hljs-comment">/// Performs copy-assignment from `source`.</span><br>    <span class="hljs-comment">///</span><br>    <span class="hljs-comment">/// `a.clone_from(&amp;b)` is equivalent to `a = b.clone()` in functionality,</span><br>    <span class="hljs-comment">/// but can be overridden to reuse the resources of `a` to avoid unnecessary</span><br>    <span class="hljs-comment">/// allocations.</span><br>    <span class="hljs-meta">#[inline]</span><br>    <span class="hljs-meta">#[stable(feature = <span class="hljs-string">&quot;rust1&quot;</span>, since = <span class="hljs-string">&quot;1.0.0&quot;</span>)]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone_from</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, source: &amp;<span class="hljs-keyword">Self</span>)<br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-keyword">Self</span>: ~<span class="hljs-keyword">const</span> Destruct,<br>    &#123;<br>        *<span class="hljs-keyword">self</span> = source.<span class="hljs-title function_ invoke__">clone</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Clone 是深度拷贝，栈内存和堆内存一起拷贝</p>
<p><strong>对于实现了 Copy 的类型，它的 clone 方法应该跟 Copy 语义相容，等同于按位拷贝</strong></p>
<blockquote>
<p>因为copy trait会依赖与clone trait</p>
</blockquote>
<h3 id="Copy-Trait">Copy Trait</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Copy</span>: <span class="hljs-built_in">Clone</span> &#123;<br>    <span class="hljs-comment">// Empty.</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>从这里可以看出，<code>Copy</code> 和 <code>Clone</code> 实际的操作是一样的</p>
<p><strong>但是 <code>Clone</code> 是程序员手动显式调用，<code>Copy</code> 是编译器隐式调用</strong></p>
<p>对于一个类型到底是应不应该实现<code>Copy Trait</code>，这是由程序员显式决定的</p>
<p>而考虑的因素就是性能</p>
<ul>
<li>如果这个类型具有确定的大小并且很小，就可以实现copy trait，所有数据都存在栈上，并且复制速度快</li>
<li>如果这个类型没有确定的大小，就只能存放在堆上，堆上的数据操作很慢，这时就不应该实现copy trait,如果实现了的话，每次赋值或者传递都会引起堆上的数据复制，很慢</li>
<li>如果这个类型有确定的大小并且很大，程序员也应该考虑不实现copy trait，因为即使能存放在栈上，但是复制所有数据仍然是很耗时的，完全复制也会很影响性能</li>
</ul>
<h4 id="实现条件">实现条件</h4>
<p>常见的数字类型、bool类型、共享借用指针&amp;，都是具有 Copy 属性的类型。而 Box、Vec、可写借用指针&amp;mut 等类型都是不具备 Copy 属性的类型。</p>
<p>对于数组类型，如果它内部的元素类型是 Copy，那么这个数组也是 Copy 类型。</p>
<p>对于 tuple 类型，如果它的每一个元素都是 Copy 类型，那么这个 tuple 会自动实现 Copy trait。</p>
<p>对于 struct 和 enum 类型，不会自动实现 Copy trait。而且只有当 struct 和 enum 内部每个元素都是 Copy 类型的时候，编译器才允许我们针对此类型实现 Copy trait</p>
<h3 id="Summary-2">Summary</h3>
<ul>
<li>
<p>在堆的数据上一定不会是 Copy 语义的。</p>
</li>
<li>
<p>栈上的数据可能是 Copy 的，也可能是 非 Copy 的。</p>
</li>
<li>
<p>Copy trait 和 Drop trait 是互斥的。非 Copy 语义的数据就会被 Drop 掉。</p>
</li>
</ul>
<h2 id="Unsafe">Unsafe</h2>
<p>Segmentation faults are generated when the CPU and OS detect that your program is attempting to access memory regions that they aren’t entitled to.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">noop</span>()<span class="hljs-punctuation">-&gt;</span>*<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">noop_local</span> = <span class="hljs-number">12345</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;noop_local: &#123;&#125; address:&#123;:p&#125;&quot;</span>, noop_local,&amp;noop_local);<br>    &amp;noop_local <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">fn_int</span> = <span class="hljs-title function_ invoke__">noop</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fn_int: &#123;:p&#125;&quot;</span>, fn_int);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;fn_int: &#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span>&#123;*fn_int&#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">danger_addr</span> = <span class="hljs-number">0x1</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">content</span> = <span class="hljs-keyword">unsafe</span>&#123;*danger_addr&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;content: &#123;&#125;&quot;</span>, content);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="std-io-Read-by-ref">std::io::Read::by_ref()</h2>
<p>首先，我们要知道 <code>std::io::Read::</code> 是会消耗它的调用方的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::prelude::*;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;foo.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buffer</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">5</span>];<br><br>    <span class="hljs-comment">// read at most five bytes</span><br>    <span class="hljs-comment">// take() consumes f</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handle</span> = f.<span class="hljs-title function_ invoke__">take</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// Error: f no longer exists  </span><br>    <span class="hljs-comment">// f.read(&amp;mut buffer)?;</span><br><br>    handle.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buffer)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Programming/" class="category-chain-item">Programming</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/Rust/" class="category-chain-item">Rust</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Learning/" class="print-no-link">#Learning</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust Learning Note</div>
      <div>http://blog.kkkzoz.top/2024/02/10/learning/Explore_Rust/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Liu Jinyi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 10, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/22/Papers/Distributed%20Transactions/omid-reloaded/" title="Paper Note: Omid, Reloaded: Scalable and Highly-Available Transaction Processing">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Paper Note: Omid, Reloaded: Scalable and Highly-Available Transaction Processing</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/22/Papers/Distributed%20Transactions/towards-transaction-as-a-service/" title="Paper Note: Towards Transaction as a Service">
                        <span class="hidden-mobile">Paper Note: Towards Transaction as a Service</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'KKKZOZ/KKKZOZ.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
