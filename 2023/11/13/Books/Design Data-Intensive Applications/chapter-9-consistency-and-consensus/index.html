

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Liu Jinyi">
  <meta name="keywords" content="">
  
    <meta name="description" content="本章是这本书最酣畅淋漓的一章，涉及到了一致性和共识问题的方方面面，知识点多而不失条理。第一部分先讲了 Linearizability, 为后面的知识点做铺垫。到了 “Ordering Guarantees” 这一小节，从因果关系的带来的 “Happened Before” 的关系开始讲起，讲到了序列号和 Lamport Timestamp，提出来 Lamport Timestamp 的一个缺点：">
<meta property="og:type" content="article">
<meta property="og:title" content="DDIA: Chapter 9 Consistency and Consensus">
<meta property="og:url" content="http://blog.kkkzoz.top/2023/11/13/Books/Design%20Data-Intensive%20Applications/chapter-9-consistency-and-consensus/index.html">
<meta property="og:site_name" content="Kelicopter&#39;s Blog">
<meta property="og:description" content="本章是这本书最酣畅淋漓的一章，涉及到了一致性和共识问题的方方面面，知识点多而不失条理。第一部分先讲了 Linearizability, 为后面的知识点做铺垫。到了 “Ordering Guarantees” 这一小节，从因果关系的带来的 “Happened Before” 的关系开始讲起，讲到了序列号和 Lamport Timestamp，提出来 Lamport Timestamp 的一个缺点：">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110202052600.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110204511807.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110205316862.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231111155713795.png">
<meta property="og:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231112155232884.png">
<meta property="article:published_time" content="2023-11-12T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-09T09:18:13.253Z">
<meta property="article:author" content="Liu Jinyi">
<meta property="article:tag" content="BookNote">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110202052600.png">
  
  
  
  <title>DDIA: Chapter 9 Consistency and Consensus - Kelicopter&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"blog.kkkzoz.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kelicopter</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="DDIA: Chapter 9 Consistency and Consensus"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-13 00:00" pubdate>
          November 13, 2023 am
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          266 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">DDIA: Chapter 9 Consistency and Consensus</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本章是这本书最酣畅淋漓的一章，涉及到了一致性和共识问题的方方面面，知识点多而不失条理。第一部分先讲了 Linearizability, 为后面的知识点做铺垫。到了 “Ordering Guarantees” 这一小节，从因果关系的带来的 “Happened Before” 的关系开始讲起，讲到了序列号和 Lamport Timestamp，提出来 Lamport Timestamp 的一个缺点：无法在某事件发生时判断是否有冲突，然后引出了全序关系广播，在全序关系广播中又讲到了和 Linearizable 之间的等价关系，最后引出共识算法。太精彩了，值得反复阅读！</p>
</blockquote>
<h2 id="Consistency-Guarantees">Consistency Guarantees</h2>
<p>Most replicated databases provide at least <em>eventual consistency</em>, which means that if you stop writing to the database and wait for some unspecified length of time, then eventually all read requests will return the same value.</p>
<p>A better name for eventual consistency may be <em>convergence</em>, as we expect all replicas to eventually converge to the same value.</p>
<blockquote>
<p><em>convergence</em>，直接译为收敛感觉最为形象，引用数学里的意思：随着某个值的变化，某个东西的状态最终趋于一个特定值。</p>
</blockquote>
<p>Systems with stronger guarantees may have worse performance or be less fault-tolerant than systems with weaker guarantees. Nevertheless, stronger guarantees can be appealing because they are easier to use correctly.</p>
<h2 id="Linearizability">Linearizability</h2>
<p>In a linearizable system, as soon as one client successfully completes a write, all clients reading from the database must be able to see the value just written. Maintaining the illusion of a single copy of the data means guaranteeing that the value read is the most recent, up-to-date value, and doesn’t come from a stale cache or replica.</p>
<blockquote>
<p>In other words, linearizability is a <em>recency guarantee</em>.</p>
</blockquote>
<h3 id="What-Makes-a-System-Linearizable">What Makes a System Linearizable?</h3>
<p>The basic idea behind linearizability is simple: to make a system appear as if there is only a single copy of the data.</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110202052600.png" alt="image-20231110202052600"></p>
<h3 id="Linearizability-Versus-Serializability">Linearizability Versus Serializability</h3>
<ul>
<li><em>Serializability</em>
<ul>
<li>Serializability is an isolation property of <em>transactions</em>, where every transaction may read and write multiple objects.</li>
<li>It guarantees that transactions behave the same as if they had executed in some serial order.</li>
<li>It is okay for that serial order to <strong>be different from</strong> the order in which transactions were actually run.</li>
</ul>
</li>
<li><em>Linearizability</em>
<ul>
<li>Linearizability is a recency guarantee on reads and writes of a register.</li>
<li>It doesn’t group operations together into transactions, so it does not prevent problems such as write skew.</li>
</ul>
</li>
</ul>
<p>A database may provide both serializability and linearizability, and this combination is known as <em>strict serializability</em> or <em>strong one-copy serializability</em>.</p>
<p><strong>Implementations of serializability based on two-phase locking or actual serial execution are typically linearizable.</strong></p>
<h3 id="Relying-on-Linearizability">Relying on Linearizability</h3>
<h4 id="Locking-and-Leader-election">Locking and Leader election</h4>
<p>A system that uses single-leader replication needs to ensure that there is indeed only one leader, not several. One way of electing a leader is to use a lock: every node that starts up tries to acquire the lock, and the one that succeeds becomes the leader.</p>
<p>No matter how this lock is implemented, it must be linearizable: all nodes must agree which node owns the lock; otherwise it is useless.</p>
<blockquote>
<p>Coordination services like Apache ZooKeeper and etcd are often used to implement distributed locks and leader election. They use consensus algorithms to implement linearizable operations in a fault-tolerant way.</p>
</blockquote>
<p>严格意义上来说， ZooKeeper 和 etcd 都只提供线性写，即可能会读到旧数据，但是你可以请求一个线性读的操作：</p>
<ul>
<li>etcd calls this a <em>quorum read</em></li>
<li>in ZooKeeper you need to call <code>sync()</code></li>
</ul>
<h4 id="Constraints-and-uniqueness-guarantees">Constraints and uniqueness guarantees</h4>
<p>Uniqueness constraints are common in databases: for example, a username or email address must uniquely identify one user, and in a file storage service there cannot be two files with the same path and filename.</p>
<p>If you want to enforce this constraint <strong>as the data is written</strong> (such that if two people try to concurrently create a user or a file with the same name, one of them will be returned an error), you need linearizability.</p>
<p>This situation is actually similar to a lock: when a user registers for your service, you can think of them acquiring a “lock” on their chosen username.</p>
<h4 id="Cross-channel-timing-dependencies">Cross-channel timing dependencies</h4>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110204511807.png" alt="image-20231110204511807"></p>
<p>If the file storage service is linearizable, then this system should work fine. If it is not linearizable, there is the risk of a race condition: the message queue (steps 3 and 4) might be faster than the internal replication inside the storage service. In this case, when the resizer fetches the image (step 5), it might see an old version of the image, or nothing at all. If it processes an old version of the image, the full-size and resized images in the file storage become permanently inconsistent.</p>
<p>This problem arises because there are two different communication channels between the web server and the resizer: the file storage and the message queue. Without the recency guarantee of linearizability, race conditions between these two channels are possible.</p>
<h3 id="Implementing-Linearizable-Systems">Implementing Linearizable Systems</h3>
<p>The most common approach to making a system fault-tolerant is to use replication. Let’s revisit the replication methods and compare whether they can be made linearizable:</p>
<ul>
<li><em>Single-leader replication (potentially linearizable)</em>
<ul>
<li>In a system with single-leader replication, the leader has the primary copy of the data that is used for writes, if you make reads from the leader, or from synchronously updated followers, they have the <em>potential</em> to be linearizable.</li>
</ul>
</li>
<li><em>Multi-leader replication (not linearizable)</em>
<ul>
<li>Systems with multi-leader replication are generally not linearizable, because they concurrently process writes on multiple nodes and asynchronously replicate them to other nodes.</li>
</ul>
</li>
<li><em>Leaderless replication (probably not linearizable)</em>
<ul>
<li>People sometimes claim that you can obtain “strong consistency” by requiring quorum reads and writes (w + r &gt; n).</li>
<li>Depending on the exact configuration of the quorums, and depending on how you define strong consistency, this is not quite true.</li>
</ul>
</li>
<li><em>Consensus algorithms (linearizable)</em>
<ul>
<li>Some consensus algorithms bear a resemblance to single-leader replication. However, consensus protocols contain measures to prevent split brain and stale replicas.</li>
</ul>
</li>
</ul>
<h4 id="Linearizability-and-quorums">Linearizability and quorums</h4>
<p>Intuitively, it seems as though strict quorum reads and writes should be linearizable in a Dynamo-style model. However, when we have variable network delays, it is possible to have race conditions, as demonstrated below:</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231110205316862.png" alt="A non-linearizable execution, despite using a strict quorum."></p>
<p>The initial value of x is 0, and a writer client is updating x to 1 by sending the write to all three replicas (n = 3, w = 3). Concurrently, client A reads from a quorum of two nodes (r = 2) and sees the new value 1 on one of the nodes. Also concurrently with the write, client B reads from a different quorum of two nodes, and gets back the old value 0 from both.</p>
<p>This execution is nevertheless not linearizable: B’s request begins after A’s request completes, but B returns the old value while A returns the new value.</p>
<blockquote>
<p>Interestingly, it is <em>possible</em> to make Dynamo-style quorums linearizable at the cost of reduced performance:</p>
<ul>
<li>A reader must perform read repair synchronously, before returning results to the application.</li>
<li>A writer must read the latest state of a quorum of nodes before sending its writes.<br>
Moreover, only linearizable read and write operations can be implemented in this way; a linearizable compare-and-set operation cannot, because it requires a consensus algorithm.</li>
</ul>
</blockquote>
<h3 id="The-Cost-of-Linearizability">The Cost of Linearizability</h3>
<h4 id="The-CAP-theorem">The CAP theorem</h4>
<p>The trade-off is as follows:</p>
<ul>
<li>If your application <em>requires</em> linearizability, and some replicas are disconnected from the other replicas due to a network problem, then some replicas cannot process requests while they are disconnected: they must either wait until the network problem is fixed, or return an error (either way, they become <em>unavailable</em>).</li>
<li>If your application does <em>not require</em> linearizability, then it can be written in a way that each replica can process requests independently, even if it is disconnected from other replicas (e.g., multi-leader). In this case, the application can remain <em>available</em> in the face of a network problem, but its behavior is not linearizable.</li>
</ul>
<blockquote>
<p>Thus, a better way of phrasing CAP would be <em>either Consistent or Available when Partitioned</em>.</p>
</blockquote>
<p>The CAP theorem as formally defined is of very narrow scope: it only considers one consistency model (namely linearizability) and one kind of fault (network partitions, vi or nodes that are alive but disconnected from each other). It doesn’t say anything about network delays, dead nodes, or other trade-offs.</p>
<p><strong>Thus, although CAP has been historically influential, it has little practical value for designing systems.</strong></p>
<h4 id="Linearizability-and-network-delays">Linearizability and network delays</h4>
<p>Although linearizability is a useful guarantee, surprisingly few systems are actually linearizable in practice.</p>
<p>If you want linearizability, the response time of read and write requests is at least proportional to the uncertainty of delays in the network.</p>
<p>A faster algorithm for linearizability does not exist, but weaker consistency models can be much faster, so this trade-off is important for latency-sensitive systems.</p>
<h2 id="Ordering-Guarantees">Ordering Guarantees</h2>
<p>Something about ordering:</p>
<ul>
<li>the main purpose of the leader in single-leader replication is to determine the <em>order of writes</em> in the replication log—that is, the order in which followers apply those writes. If there is no single leader, conflicts can occur due to concurrent operations.</li>
<li>Serializability, is about ensuring that transactions behave as if they were executed in <em>some sequential order</em>.</li>
<li>The use of timestamps and clocks in distributed systems is another attempt to introduce order into a disorderly world, for example to determine which one of two writes happened later.</li>
</ul>
<h3 id="Ordering-and-Causality">Ordering and Causality</h3>
<p>There are several reasons why ordering keeps coming up, and one of the reasons is that it helps preserve <em>causality</em>.</p>
<blockquote>
<p>Causality imposes an ordering on events: cause comes before effect; a message is sent before that message is received; the question comes before the answer.</p>
</blockquote>
<p>If a system obeys the ordering imposed by causality, we say that it is <em>causally consistent</em>.</p>
<h4 id="The-Causal-order-is-not-a-total-order">The Causal order is not a total order</h4>
<p>A <em>total order</em> allows any two elements to be compared, so if you have two elements, you can always say which one is greater and which one is smaller.</p>
<p>The difference between a total order and a partial order is reflected in different database consistency models:</p>
<ul>
<li><em>Linearizability</em>
<ul>
<li>In a linearizable system, we have a <em>total order</em> of operations: if the system behaves as if there is only a single copy of the data, and every operation is atomic, this means that for any two operations we can always say which one happened first.</li>
</ul>
</li>
<li><em>Causality</em>
<ul>
<li>We said that two operations are concurrent if neither happened before the other. Two events are ordered if they are causally related (one happened before the other), but they are incomparable if they are concurrent. This means that causality defines a <em>partial order</em>, not a total order: some operations are ordered with respect to each other, but some are incomparable.</li>
</ul>
</li>
</ul>
<p>Therefore, according to this definition, there are no concurrent operations in a linearizable datastore: there must be a single timeline along which all operations are totally ordered.</p>
<p>Concurrency would mean that <strong>the timeline branches and merges again</strong>—and in this case, operations on different branches are incomparable.</p>
<h4 id="Linearizability-is-stronger-than-causal-consistency">Linearizability is stronger than causal consistency</h4>
<p>So what is the relationship between the causal order and linearizability? The answer is that linearizability implies causality: any system that is linearizable will preserve causality correctly.</p>
<p>The good news is that a middle ground is possible. Linearizability is not the only way of preserving causality—there are other ways too. A system can be causally consistent without incurring the performance hit of making it linearizable.</p>
<p>In fact, causal consistency is the strongest possible consistency model that does not slow down due to network delays, and remains available in the face of network failures.</p>
<h3 id="Sequence-Number-Ordering">Sequence Number Ordering</h3>
<p>However, there is a better way: we can use sequence numbers or timestamps to order events. A timestamp need not come from a time-of-day clock. It can instead come from a logical clock, which is an algorithm to generate a sequence of numbers to identify operations, typically using counters that are incremented for every operation.</p>
<p>Such sequence numbers or timestamps are compact, and they provide a total order.</p>
<p>只要我们获得了所有事件的全局排序，那么各种一致性模型对于读写操作所呈现的排序要求，很自然就能得到满足。</p>
<p>In particular, we can create sequence numbers in a total order that is consistent with causality: we promise that if operation A causally happened before B, then A occurs before B in the total order (A has a lower sequence number than B).</p>
<blockquote>
<p>Concurrent operations may be ordered arbitrarily.</p>
<p>Such a total order captures all the causality information, but also imposes more ordering than strictly required by causality.</p>
</blockquote>
<p><strong>In a database with single-leader replication, the replication log defines a total order of write operations that is consistent with causality.</strong></p>
<h4 id="Non-causal-sequence-number-generators">Non-causal sequence number generators</h4>
<p>If there is not a single leader (perhaps because you are using a multi-leader or leaderless database, or because the database is partitioned), it is less clear how to generate sequence numbers for operations. Various methods are used in practice:</p>
<ul>
<li>Each node can generate its own independent set of sequence numbers. For example, if you have two nodes, one node can generate only odd numbers and the other only even numbers.</li>
<li>You can attach a timestamp from a time-of-day clock (physical clock) to each operation. Such timestamps are not sequential, but if they have sufficiently high resolution, they <em>might be sufficient</em> to totally order operations.</li>
<li>You can preallocate blocks of sequence numbers.</li>
</ul>
<p>These three options all perform better and are more scalable than pushing all operations through a single leader that increments a counter.</p>
<p>However, they all have a problem: the sequence numbers they generate are <em>not consistent with causality</em>.</p>
<h4 id="Lamport-timestamps">Lamport timestamps</h4>
<blockquote>
<p>通过说明分布式下序列号生成失去了因果关系的一致性，引出了一种新的解决方法：Lamport Timestamp.</p>
</blockquote>
<p>Although the three sequence number generators just described are inconsistent with causality, there is actually a simple method for generating sequence numbers that is consistent with causality. It is called a <em>Lamport timestamp</em>(“time, clocks, and the ordering of event in the distributed systems”).</p>
<p>Each node has a unique identifier, and each node keeps a counter of the number of operations it has processed. The Lamport timestamp is then simply a pair of <code>(counter, node ID)</code>.</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231111155713795.png" alt="Lamport timestamps provide a total ordering consistent with causality."></p>
<p>A Lamport timestamp bears no relationship to a physical time-of-day clock, <strong>but it provides total ordering</strong>: if you have two timestamps, the one with a greater counter value is the greater timestamp; if the counter values are the same, the one with the greater node ID is the greater timestamp.</p>
<p>The key idea about Lamport timestamps, which makes them consistent with causality, is the following: every node and every client keeps track of the <em>maximum</em> counter value it has seen so far, and includes that maximum on every request.</p>
<p>When a node receives a request or response with a maximum counter value greater than its own counter value, it immediately increases its own counter to that maximum.</p>
<p>As long as the maximum counter value is carried along with every operation, <strong>this scheme ensures that the ordering from the Lamport timestamps is consistent with causality, because every causal dependency results in an increased timestamp.</strong></p>
<p>直观一点解释，因果性体现在哪些方面：</p>
<ul>
<li>同一个进程内部的前后两个操作<strong>可能</strong>具有因果性：
<ul>
<li>Lamport Timestamp 保证了后进行的操作时间戳一定比前面进行的操作大。</li>
</ul>
</li>
<li>不同进程之间，消息的发送方和消息的接收方<strong>可能</strong>具有因果性：
<ul>
<li>Lamport Timestamp 保证了消息的接收方的时间戳一定比消息发送方的时间戳大。</li>
</ul>
</li>
</ul>
<h4 id="Timestamp-ordering-is-not-sufficient">Timestamp ordering is not sufficient</h4>
<blockquote>
<p>“很有启发的一集。”</p>
</blockquote>
<p>Although Lamport timestamps define a total order of operations that is consistent with causality, they are not quite sufficient to solve many common problems in distributed systems.</p>
<p>For example, consider a system that needs to ensure that a username uniquely identifies a user account. If two users concurrently try to create an account with the same username, one of the two should succeed and the other should fail.</p>
<p>At first glance, it seems as though a total ordering of operations (e.g., using Lamport timestamps) should be sufficient to solve this problem: if two accounts with the same username are created, pick the one with the lower timestamp as the winner (the one who grabbed the username first), and let the one with the greater timestamp fail. Since timestamps are totally ordered, this comparison is always valid.</p>
<p>This approach works for determining the winner after the fact: <strong>once you have collected all the username creation operations in the system, you can compare their timestamps.</strong> However, it is not sufficient when a node has just received a request from a user to create a username, and needs to decide <em>right now</em> whether the request should succeed or fail.</p>
<p>The problem here is that <strong>the total order of operations only emerges after you have collected all of the operations.</strong> If another node has generated some operations, but you don’t yet know what they are, you cannot construct the final ordering of operations.</p>
<p>To conclude: <strong>in order to implement something like a uniqueness constraint for usernames, it’s not sufficient to have a total ordering of operations — you also need to know when that order is finalized.</strong></p>
<p>If you have an operation to create a username, and you are sure that no other node can insert a claim for the same username ahead of your operation in the total order, then you can safely declare the operation successful. This idea of knowing when your total order is finalized is captured in the topic of <em>total order broadcast</em>.</p>
<h3 id="Total-Order-Broadcast">Total Order Broadcast</h3>
<p>As discussed, single-leader replication determines a total order of operations by choosing one node as the leader and sequencing all operations on a single CPU core on the leader.</p>
<p>The challenge then is how to scale the system if the throughput is greater than a single leader can handle, and also how to handle failover if the leader fails. In the distributed systems literature, this problem is known as <em>total order broadcast</em> or <em>atomic broadcast</em>.</p>
<p>很多时候系统里的全序关系都是由 single-leader 维护的，因为所有的读和写请求都由它处理，最后写入日志的顺序就是整个系统中的全序顺序。但是如果系统的吞吐量大于了单个节点能够处理的范围或者当前的 Leader 挂掉了，全序关系广播就能发挥作用了。</p>
<p>Total order broadcast is usually described as a protocol for exchanging messages between nodes. Informally, it requires that two safety properties always be satisfied:</p>
<ul>
<li><em>Reliable delivery</em>
<ul>
<li>No messages are lost: if a message is delivered to one node, it is delivered to all nodes.</li>
</ul>
</li>
<li><em>Totally ordered delivery</em>
<ul>
<li>Messages are delivered to every node in the same order.</li>
</ul>
</li>
</ul>
<h4 id="Using-total-order-broadcast">Using total order broadcast</h4>
<p>Consensus services such as ZooKeeper and etcd actually implement total order broadcast.</p>
<blockquote>
<p>This fact is a hint that there is a strong connection between total order broadcast and consensus.</p>
</blockquote>
<p>Total order broadcast is exactly what you need for database replication: if every message represents a write to the database, and every replica processes the same writes in the same order, then the replicas will remain consistent with each other (aside from any temporary replication lag). This principle is known as <em>state machine replication</em>.</p>
<p>An important aspect of total order broadcast is that <strong>the order is fixed at the time the messages are delivered</strong>: a node is not allowed to retroactively insert a message into an earlier position in the order if subsequent messages have already been delivered. This fact makes total order broadcast stronger than timestamp ordering.</p>
<p>Another way of looking at total order broadcast is that it is a way of creating a log (as in a replication log, transaction log, or write-ahead log): delivering a message is like appending to the log. Since all nodes must deliver the same messages in the same order, all nodes can read the log and see the same sequence of messages.</p>
<h4 id="Implementing-linearizable-storage-using-total-order-broadcast">Implementing linearizable storage using total order broadcast</h4>
<blockquote>
<p>注意这节的小标题是用 total order broadcast 实现一个 linearizable storage.</p>
</blockquote>
<p>Total order broadcast is asynchronous: messages are guaranteed to be delivered reliably in a fixed order, but there is no guarantee about <em>when</em> a message will be delivered (so one recipient may lag behind the others). By contrast, linearizability is a <em>recency guarantee</em>: a read is guaranteed to see the latest value written.</p>
<p>所以如何解决前文提到的那个用户名限制的问题呢？</p>
<p>Imagine that for every possible username, you can have a linearizable register with an atomic compare-and-set operation.</p>
<p>Every register initially has the value null (indicating that the username is not taken). When a user wants to create a username, you execute a compare-and-set operation on the register for that username, setting it to the user account ID, under the condition that the previous register value is null. If multiple users try to concurrently grab the same username, only one of the compare-and-set operations will succeed, because the others will see a value other than null (due to linearizability).</p>
<blockquote>
<p>为什么 compare-and-set 机制需要 linearizability 呢？</p>
<p>你可以这么想：compare-and-set 操作是有 <em>recency</em> 需求的，即必须保证每次 compare 操作都一定能读到最新的数据，然而只有 linearizability 才能提供这种 <em>recency guarantee</em>。</p>
</blockquote>
<p>You can implement such a linearizable compare-and-set operation as follows by using total order broadcast as an append-only log:</p>
<ol>
<li>Append a message to the log, tentatively indicating the username you want to claim.</li>
<li>Read the log, and wait for the message you appended to be delivered back to you.</li>
<li>Check for any messages claiming the username that you want.</li>
</ol>
<ul>
<li>If the first message for your desired username is your own message, then you are successful: you can commit the username claim (perhaps by appending another message to the log) and acknowledge it to the client.</li>
<li>If the first message for your desired username is from another user, you abort the operation.</li>
</ul>
<blockquote>
<p>A similar approach can be used to implement serializable multi-object transactions on top of a log.</p>
</blockquote>
<p>While this procedure ensures linearizable writes, it doesn’t guarantee linearizable reads — if you read from a store that is asynchronously updated from the log, it may be stale. (To be precise, the procedure described here provides <em>sequential consistency</em>, sometimes also known as <em>timeline consistency</em>, a slightly weaker guarantee than <em>linearizability</em>.) To make reads linearizable, there are a few options:</p>
<ul>
<li>You can sequence reads through the log by appending a message, reading the log, and performing the actual read when the message is delivered back to you.
<ul>
<li>etcd somehow works like this.</li>
</ul>
</li>
<li>If the log allows you to fetch the position of the latest log message in a linearizable way, you can query that position, wait for all entries up to that position to be delivered to you, and then perform the read.
<ul>
<li>This is the idea behind ZooKeeper’s <code>sync()</code> operation.</li>
</ul>
</li>
<li>You can make your read from a replica that is synchronously updated on writes, and is thus sure to be up to date.
<ul>
<li>This technique is used in chain replication.</li>
</ul>
</li>
</ul>
<h4 id="Implementing-total-order-broadcast-using-linearizable-storage">Implementing total order broadcast using linearizable storage</h4>
<blockquote>
<p>用 linearizable storage 实现一个 total order broadcast</p>
</blockquote>
<p>The easiest way is to assume you have a linearizable register that stores an integer and that has an atomic increment-and-get operation. Alternatively, an atomic compare-and-set operation would also do the job.</p>
<p>The algorithm is simple:</p>
<ul>
<li>For every message you want to send through total order broadcast, you increment-and-get the linearizable integer</li>
<li>Attach the value you got from the register as a sequence number to the message.</li>
<li>You can then send the message to all nodes (resending any lost messages), and the recipients will deliver the messages consecutively by sequence number.</li>
</ul>
<p>Note that unlike Lamport timestamps, the numbers you get from incrementing the linearizable register form a sequence with no gaps. <strong>Thus, if a node has delivered message 4 and receives an incoming message with a sequence number of 6, it knows that it must wait for message 5 before it can deliver message 6.</strong></p>
<p>这里结合 linearizable storage 来说明一下如何利用全序关系广播来维护唯一性限制的，用注册用户名来说明：</p>
<p>首先分为上层应用和下层协议：</p>
<ol>
<li>用户在输入用户名后，上层应用向下层协议提出消息。</li>
<li>上层应用监视下层协议的消息提交，如果第一条有关某用户名的声称是自己提交的，那么该用户名可用，否则已经被占用。</li>
<li>下层协议收到消息后，向 linearizable storage 执行 increment-and-get 操作获取序列号。</li>
<li>获取序列号后，下层协议先向自己的上层应用提交该消息，再向其他所有节点广播该消息。</li>
</ol>
<p>步骤 3 是需要时间的，如果上层应用在提出消息后还没收到自己的消息时，收到了来自于其他节点的关于相同用户名的声称，则知晓该用户名已经被占用。</p>
<p>This is the key difference between total order broadcast and timestamp ordering.</p>
<p>How hard could it be to make a linearizable integer with an atomic increment-and-get operation?</p>
<p>As usual, if things never failed, it would be easy: you could just keep it in a variable on one node. The problem lies in handling the situation when network connections to that node are interrupted, and restoring the value when that node fails.</p>
<p>In general, if you think hard enough about linearizable sequence number generators, you inevitably end up with a consensus algorithm.</p>
<p>This is no coincidence: it can be proved that a linearizable compare-and-set (or increment-and-get) register and total order broadcast are <em>both equivalent to consensus</em>. That is, if you can solve one of these problems, you can transform it into a solution for the others.</p>
<p>This is quite a profound and surprising insight!</p>
<h2 id="Distributed-Transactions-and-Consensus">Distributed Transactions and Consensus</h2>
<p>Consensus is one of the most important and fundamental problems in distributed computing. On the surface, it seems simple: informally, the goal is simply to <em>get several nodes to agree on something</em>.</p>
<h3 id="Atomic-Commit-and-Two-Phase-Commit-2-PC">Atomic Commit and Two-Phase Commit (2 PC)</h3>
<h4 id="Introduction-to-two-phase-commit">Introduction to two-phase commit</h4>
<p>Two-phase commit is an algorithm for achieving atomic transaction commit across multiple nodes—i.e., to ensure that either all nodes commit or all nodes abort.</p>
<p><img src="https://kkkzoz-1304409899.cos.ap-chengdu.myqcloud.com/img/image-20231112155232884.png" alt="A successful execution of two-phase commit"></p>
<h4 id="A-system-of-promises">A system of promises</h4>
<p>In a bit more detail:</p>
<ol>
<li>When the application wants to begin a distributed transaction, it requests a transaction ID from the coordinator. This transaction ID is globally unique.</li>
<li>The application begins a single-node transaction on each of the participants, and attaches the globally unique transaction ID to the single-node transaction. All reads and writes are done in one of these single-node transactions.</li>
<li>When the application is ready to commit, the coordinator sends a prepare request to all participants, tagged with the global transaction ID.</li>
<li>When a participant receives the prepare request, it makes sure that it can definitely commit the transaction under all circumstances.</li>
<li>When the coordinator has received responses to all prepare requests, it makes a definitive decision on whether to commit or abort the transaction.</li>
<li>Once the coordinator’s decision has been written to disk, the commit or abort request is sent to all participants. If this request fails or times out, the coordinator must retry forever until it succeeds.</li>
</ol>
<p>Thus, the protocol contains two crucial “points of no return”:</p>
<ol>
<li>When a participant votes “yes,” it promises that it will definitely be able to commit later (although the coordinator may still choose to abort).</li>
<li>Once the coordinator decides, that decision is irrevocable. Those promises ensure the atomicity of 2 PC.</li>
</ol>
<h3 id="Distributed-Transactions-in-Practice">Distributed Transactions in Practice</h3>
<p>Some implementations of distributed transactions carry a heavy performance penalty —for example, distributed transactions in MySQL are reported to be over 10 times slower than single-node transactions.</p>
<p>Two quite different types of distributed transactions are often conflated:</p>
<ul>
<li><em>Database-internal distributed transactions</em>
<ul>
<li>Some distributed databases (i.e., databases that use replication and partitioning in their standard configuration) support internal transactions among the nodes of that database.</li>
<li>In this case, all the nodes participating in the transaction are running the same database software.</li>
</ul>
</li>
<li><em>Heterogeneous distributed transactions</em>
<ul>
<li>In a <em>heterogeneous</em> transaction, the participants are two or more different technologies: for example, two databases from different vendors, or even non-database systems such as message brokers.</li>
</ul>
</li>
</ul>
<h4 id="Limitations-of-distributed-transactions">Limitations of distributed transactions</h4>
<p>XA transactions solve the real and important problem of keeping several participant data systems consistent with each other, but as we have seen, they also introduce major operational problems. In particular, the key realization is that the transaction coordinator is itself a kind of database:</p>
<ul>
<li>If the coordinator is not replicated but runs only on a single machine, it is a single point of failure for the entire system.</li>
<li>Many server-side applications are developed in a stateless model (as favored by HTTP), with all persistent state stored in a database.</li>
<li>Since XA needs to be compatible with a wide range of data systems, it is necessarily a lowest common denominator.</li>
</ul>
<h3 id="Fault-Tolerant-Consensus">Fault-Tolerant Consensus</h3>
<p>The consensus problem is normally formalized as follows: one or more nodes may <em>propose</em> values, and the consensus algorithm <em>decides</em> on one of those values.</p>
<p>In this formalism, a consensus algorithm must satisfy the following properties:</p>
<ul>
<li><em>Uniform agreement</em>
<ul>
<li>No two nodes decide differently.</li>
</ul>
</li>
<li><em>Integrity</em>
<ul>
<li>No node decides twice.</li>
</ul>
</li>
<li><em>Validity</em>
<ul>
<li>If a node decides value v, then v was proposed by some node.</li>
</ul>
</li>
<li><em>Termination</em>
<ul>
<li>Every node that does not crash eventually decides some value.</li>
<li>This is a <em>liveness</em> property.</li>
<li>In particular, 2PC does not meet the requirements for termination.</li>
</ul>
</li>
</ul>
<p>The uniform agreement and integrity properties define the core idea of consensus: <strong>everyone decides on the same outcome, and once you have decided, you cannot change your mind.</strong></p>
<h4 id="Consensus-algorithms-and-total-order-broadcast">Consensus algorithms and total order broadcast</h4>
<p>The best-known fault-tolerant consensus algorithms are Viewstamped Replication (VSR), Paxos, Raft, and Zab. There are quite a few similarities between these algorithms, but they are not the same.</p>
<p>Remember that total order broadcast requires messages to be delivered exactly once, in the same order, to all nodes. If you think about it, this is equivalent to performing several rounds of <em>consensus</em>: in each round, nodes propose the message that they want to send next, and then decide on the next message to be delivered in the total order.</p>
<p>So, total order broadcast is equivalent to repeated rounds of consensus (each consensus decision corresponding to one message delivery):</p>
<ul>
<li>Due to the agreement property of consensus, all nodes decide to deliver the same messages in the same order.</li>
<li>Due to the integrity property, messages are not duplicated.</li>
<li>Due to the validity property, messages are not corrupted and not fabricated out of thin air.</li>
<li>Due to the termination property, messages are not lost.</li>
</ul>
<p>Viewstamped Replication, Raft, and Zab implement total order broadcast directly, because that is more efficient than doing repeated rounds of one-value-at-a-time consensus. In the case of Paxos, this optimization is known as Multi-Paxos.</p>
<h4 id="Single-leader-replication-and-consensus">Single-leader replication and consensus</h4>
<blockquote>
<p>粗看本章的内容，好像第 5 章讲到的 single-leader replication 已经是个全序关系广播了：it takes all the writes to the leader and applies them to the followers in the same order, thus keeping replicas up to date.</p>
<p>作者在这个小节回答了这个疑问。</p>
</blockquote>
<p>The answer comes down to how the leader is chosen. If the leader is manually chosen and configured by the humans in your operations team, you essentially have a “consensus algorithm” of the dictatorial variety: only one node is allowed to accept writes (i.e., make decisions about the order of writes in the replication log), and if that node goes down, the system becomes unavailable for writes until the operators manually configure a different node to be the leader. Such a system can work well in practice, but it does not satisfy the termination property of consensus because it requires human intervention in order to make progress.</p>
<p>Some databases perform automatic leader election and failover, promoting a follower to be the new leader if the old leader fails. This brings us closer to fault-tolerant total order broadcast, and thus to solving consensus.</p>
<p>However, there is a problem. We previously discussed the problem of split brain, and said that all nodes need to agree who the leader is—otherwise two different nodes could each believe themselves to be the leader, and consequently get the database into an inconsistent state. Thus, we need consensus in order to elect a leader. But if the consensus algorithms described here are actually total order broadcast algorithms, and total order broadcast is like single-leader replication, and single-leader replication requires a leader, then…</p>
<blockquote>
<p>It seems that in order to elect a leader, we first need a leader. In order to solve consensus, we must first solve consensus. How do we break out of this conundrum?</p>
</blockquote>
<h4 id="Epoch-numbering-and-quorums">Epoch numbering and quorums</h4>
<p>All of the consensus protocols discussed so far internally use a leader in some form or another, but they don’t guarantee that the leader is unique. Instead, they can make a weaker guarantee: the protocols define an <em>epoch number</em> (called the <em>ballot number</em> in Paxos, <em>view number</em> in Viewstamped Replication, and <em>term number</em> in Raft) and guarantee that <strong>within each epoch, the leader is unique.</strong></p>
<p>Thus, we have two rounds of voting: once to choose a leader, and a second time to vote on a leader’s proposal. The key insight is that the quorums for those two votes must overlap.</p>
<h4 id="Limitations-of-consensus">Limitations of consensus</h4>
<p>The benefits of consensus algorithm come at a cost:</p>
<ul>
<li>The process by which nodes vote on proposals before they are decided is a kind of synchronous replication.</li>
<li>Consensus systems always require a strict majority to operate. This means you need a minimum of three nodes in order to tolerate one failure.</li>
<li>Consensus systems generally rely on timeouts to detect failed nodes. Frequent leader elections result in terrible performance because the system can end up spending more time choosing a leader than doing any useful work.</li>
<li>Sometimes, consensus algorithms are particularly sensitive to network problems.</li>
</ul>
<h3 id="Membership-and-Coordination-Services">Membership and Coordination Services</h3>
<p>As an application developer, you will rarely need to use ZooKeeper directly, because it is actually not well suited as a general-purpose database. It is more likely that you will end up relying on it indirectly via some other project: for example, HBase, Hadoop YARN, OpenStack Nova, and Kafka all rely on ZooKeeper running in the background.</p>
<p>ZooKeeper and etcd are designed to hold small amounts of data that can fit entirely in memory. That small amount of data is replicated across all the nodes using a fault-tolerant total order broadcast algorithm.</p>
<blockquote>
<p>Total order broadcast is just what you need for database replication: if each message represents a write to the database, applying the same writes in the same order keeps replicas consistent with each other.</p>
</blockquote>
<p>ZooKeeper is modeled after Google’s Chubby lock service, implementing not only total order broadcast (and hence consensus), but also an interesting set of other features that turn out to be particularly useful when building distributed systems:</p>
<ul>
<li><em>Linearizable atomic operations</em>
<ul>
<li>Using an atomic compare-and-set operation, you can implement a lock.</li>
</ul>
</li>
<li><em>Total ordering of operations</em>
<ul>
<li>when some resource is protected by a lock or lease, you need a <em>fencing token</em> to prevent clients from conflicting with each other in the case of a process pause.</li>
</ul>
</li>
<li><em>Failure detection</em></li>
<li><em>Change notifications</em></li>
</ul>
<h2 id="Summary">Summary</h2>
<blockquote>
<p>之前几章的 Summary 我都是随便看看，但这章的 Summary 真的有含金量，所以还是总结一波。</p>
</blockquote>
<p>We looked in depth at linearizability, a popular consistency model: its goal is to make replicated data appear as though there were only a single copy, and to make all operations act on it atomically.</p>
<p>We also explored causality, which imposes an ordering on events in a system (what happened before what, based on cause and effect). Unlike linearizability, which puts all operations in a single, totally ordered timeline, causality provides us with a weaker consistency model: some things can be concurrent, so the version history is like a timeline with branching and merging. Causal consistency does not have the coordination overhead of linearizability and is much less sensitive to network problems.</p>
<p>However, even if we capture the causal ordering (for example using Lamport timestamps), we saw that some things cannot be implemented this way: We considered the example of ensuring that a username is unique and rejecting concurrent registrations for the same username.This problem led us toward <em>consensus</em>.</p>
<p>With some digging, it turns out that a wide range of problems are actually reducible to consensus and are equivalent to each other:</p>
<ul>
<li><em>Linearizable compare-and-set registers</em>
<ul>
<li>The register needs to atomically <em>decide</em> whether to set its value, based on whether its current value equals the parameter given in the operation.</li>
</ul>
</li>
<li><em>Atomic transaction commit</em>
<ul>
<li>A database must <em>decide</em> whether to commit or abort a distributed transaction.</li>
</ul>
</li>
<li><em>Total order broadcast</em>
<ul>
<li>The messaging system must <em>decide</em> on the order in which to deliver messages.</li>
</ul>
</li>
<li><em>Locks and leases</em>
<ul>
<li>When several clients are racing to grab a lock or lease, the lock <em>decides</em> which one successfully acquired it.</li>
</ul>
</li>
<li><em>Membership/coordination service</em>
<ul>
<li>Given a failure detector (e.g., timeouts), the system must <em>decide</em> which nodes are alive, and which should be considered dead because their sessions timed out.</li>
</ul>
</li>
<li><em>Uniqueness constraint</em>
<ul>
<li>When several transactions concurrently try to create conflicting records with the same key, the constraint must <em>decide</em> which one to allow and which should fail with a constraint violation.</li>
</ul>
</li>
</ul>
<p><strong>All of these are straightforward if you only have a single node, or if you are willing to assign the decision-making capability to a single node.</strong> This is what happens in a single-leader database: all the power to make decisions is vested in the leader, which is why such databases are able to provide linearizable operations, uniqueness constraints, a totally ordered replication log, and more.</p>
<p>However, if that single leader fails, there are three ways of handling that situation:</p>
<ul>
<li>Wait for the leader to recover, and accept that the system will be blocked in the meantime.</li>
<li>Manually fail over by getting humans to choose a new leader node and reconfigure the system to use it.</li>
<li>Use an algorithm to automatically choose a new leader. This approach requires a <em>consensus</em> algorithm, and it is advisable to use a proven algorithm that correctly handles adverse network conditions.</li>
</ul>
<p>Although a single-leader database can provide linearizability without executing a consensus algorithm on every write, it still requires consensus to maintain its leadership and for leadership changes.</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Design-Data-Intensive-Applications/" class="category-chain-item">Design Data-Intensive Applications</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/BookNote/" class="print-no-link">#BookNote</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>DDIA: Chapter 9 Consistency and Consensus</div>
      <div>http://blog.kkkzoz.top/2023/11/13/Books/Design Data-Intensive Applications/chapter-9-consistency-and-consensus/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Liu Jinyi</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>November 13, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/15/Papers/zab/" title="Paper Note: Zab: High-performance broadcast for primary-backup systems">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Paper Note: Zab: High-performance broadcast for primary-backup systems</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/12/Papers/cap-twelve-years-later/" title="Paper Note: CAP Twelve Years Later: How the &#34;Rules&#34; have Changed">
                        <span class="hidden-mobile">Paper Note: CAP Twelve Years Later: How the &#34;Rules&#34; have Changed</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'KKKZOZ/KKKZOZ.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
